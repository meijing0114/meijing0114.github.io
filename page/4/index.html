<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="meijing0114的博客" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="记录科技与生活">
<meta property="og:type" content="website">
<meta property="og:title" content="meijing0114的博客">
<meta property="og:url" content="http://meijing0114.com/page/4/index.html">
<meta property="og:site_name" content="meijing0114的博客">
<meta property="og:description" content="记录科技与生活">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="meijing0114的博客">
<meta name="twitter:description" content="记录科技与生活">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"always"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://meijing0114.com/page/4/"/>

  <title> meijing0114的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?a5a4534386a17bda81a3d4f5669e4b7b";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">meijing0114的博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/11/30/php扩展与嵌入-如何在linux下配置LAMP环境/" itemprop="url">
                  php扩展与嵌入-如何在linux下配置LAMP环境
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-11-30T12:51:46+08:00" content="Nov 30 2014">
              Nov 30 2014
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/php扩展/" itemprop="url" rel="index">
                    <span itemprop="name">php扩展</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/11/30/php扩展与嵌入-如何在linux下配置LAMP环境/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/11/30/php扩展与嵌入-如何在linux下配置LAMP环境/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="php扩展与嵌入-–-如何在linux下配置LAMP环境"><a href="#php扩展与嵌入-–-如何在linux下配置LAMP环境" class="headerlink" title="php扩展与嵌入 – 如何在linux下配置LAMP环境"></a>php扩展与嵌入 – 如何在linux下配置LAMP环境</h1><p>在linux下面，使用源码包编译的方式安装LAMP，可以对内部的编译机制和php的模块加载等方面有更加深入的了解。</p>
<p>所谓LAMP指的是Linux+Apache+Mysql+Php，这些软件安装完毕了之后，就算是成功搭建了进行php开发的环境了。</p>
<h2 id="下载源码包："><a href="#下载源码包：" class="headerlink" title="下载源码包："></a>下载源码包：</h2><ul>
<li>apache：wget <a href="http://apache.dataguru.cn//httpd/httpd-2.4.7.tar.bz2" target="_blank" rel="external">http://apache.dataguru.cn//httpd/httpd-2.4.7.tar.bz2</a></li>
<li>mysql：直接用apt-get安装好了，这个源码新版本的比较难找。</li>
<li>php：wget <a href="http://cn2.php.net/distributions/php-5.5.7.tar.bz2" target="_blank" rel="external">http://cn2.php.net/distributions/php-5.5.7.tar.bz2</a></li>
</ul>
<p>下载完了源码包之后，要进行解压缩，基本的解压缩命令如下：<br><a href="http://www.cnblogs.com/eoiioe/archive/2008/09/20/1294681.html" target="_blank" rel="external">解压命令</a></p>
<p>针对.tar.bz2就是 tar jxvf<br>针对.tar.gz 就是tar zxvf</p>
<h2 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h2><p>首先说安装mysql。因为对于mysql来说，源码包比较难找，其实也没必要通过编译的方式安装。所以最方便的方式就是直接使用apt-get的安装方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install mysql-client</div><div class="line">sudo apt-get install mysql-server</div></pre></td></tr></table></figure>
<p>按照提示操作了之后，就完成了安装的大部分。在提示中要求设定用户名和密码，这个是连接数据库主要所需要的参数。<br>接下来就用这个命令进行一下检测：</p>
<p><code>mysql -uusername -ppassword</code></p>
<p>把username和password换成本来设置的值，然后看一下mysql是否安装成功了。<br>正常情况下mysql应该是被注册为linux的服务了。可以通过如下命令察看一下：</p>
<p><code>chkconfig --list</code><br>查看所有已注册的服务。</p>
<h2 id="安装apache"><a href="#安装apache" class="headerlink" title="安装apache"></a>安装apache</h2><p>安装apache的时候，首先解压缩并且进入源码目录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tar jxvf apache-version.tar.bz2</div><div class="line">cd apache-version/</div></pre></td></tr></table></figure>
<p>然后对apache进行配置：</p>
<p><code>./configure --prefix=/usr/local/apache --enable-module=so --enable-module=rewrite --enable-shared=max</code></p>
<ul>
<li>这里给出的prefix参数代表安装的目录。</li>
<li>htdocsdir参数代表apache服务器的localhost文件位置。</li>
<li>enable-module参数则启动和so和rewrite两个模块。so是用来提供DSO支持的apache核心模块。rewrite是实现地址重写的模块。像这些模块都是不能动态的加载进去的，以后需要的话还得重新编译源码，所以推荐都加载进去。</li>
<li>enable-shared=max参数是指定把so以外所有的apache标准模块都编译成DSO模块，而不是apache核心内。<br>然后就开始：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">make</div><div class="line">make install</div></pre></td></tr></table></figure>
<p>接下来需要把apache设定为linux的服务：<br>首先复制启动文件到服务目录下：</p>
<p><code>cp /usr/local/apache2/bin/apachectl /etc/init.d/httpd</code></p>
<p>然后打开服务文件：<br>vim /etc/init.d/httpd</p>
<p>在#!/bin/sh 后面加上下面两行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#chkconfig:345 85 15</div><div class="line">#description: Start and stops the Apache HTTP Server.</div></pre></td></tr></table></figure>
<ul>
<li>chkconfig:后面定义的使启动服务的运行级别(例子中使2345启动改服务),以及关闭和启动服务的顺序,(上例中关闭服务的顺序使8,启动的顺序使92)</li>
<li>descriptions:对改服务的描述</li>
</ul>
<p>接下来更改文件的执行权限，并且增加服务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">chmod +x /etc/rc.d/init.d/httpd</div><div class="line">chkconfig –add httpd</div></pre></td></tr></table></figure>
<p>这样对apache的配置就完成了。</p>
<p>注意：在apache配置的时候可能会出现出现缺包的情况，我之前碰到的是zlib，可以通过下载zlib的源码包，并且同样进行配置安装的形式，在配置的时候可以指定安装目录，比如是/usr/local/zlib<br>那么再次配置apahce的时候就要加上<br>–with-zlib=/usr/loca/zlib<br>来把这个依赖添加上。<br>别的包也是同样的道理。</p>
<h2 id="php安装"><a href="#php安装" class="headerlink" title="php安装"></a>php安装</h2><p>同样要执行解压缩和进入目录的操作。<br>接下来是配置的过程：</p>
<p><code>./configure --prefix=[php安装目录] --with-config-file-path=[php安装目录] --with-apxs2=[apache安装目录]/bin/apxs  --with-mysql=[mysql安装目录] --enable-debug --enable-maintainer-zts</code></p>
<p>如果还想要添加别的库的话，就用–with-库名=[库安装目录]<br>–enable-debug参数会在出错的时候输出很多有用的信息，从而快速定位错误。<br>而-enable-maintainer-zts则会让PHP思考在多线程环境中的行为，并且可以让你捕获常见的程序错误，这些错误在非线程环境中不会引起问题，但在多线程环境中却使你的扩展变得不可用。<br>接下来进入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">make</div><div class="line">make install</div></pre></td></tr></table></figure>
<p>常见的错误可以看下面这个链接：<br><a href="http://lyp.cn/350_how-to-fix-php-compile-errors" target="_blank" rel="external">http://lyp.cn/350_how-to-fix-php-compile-errors</a><br>如果没有yum包的话，找到相应的apt-get包也ok的。</p>
<p>接下来在apache中进行配置：<br>vim  /usr/local/apache/conf/httpd.conf<br>然后在AddType中添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">AddType application/x-httpd-php .php</div><div class="line">AddType application/x-httpd-php-source .phps</div></pre></td></tr></table></figure>
<p>在DirectoryIndex增加 index.php，以便Apache识别PHP格式的index</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;IfModule dir_module&gt;</div><div class="line">    DirectoryIndex index.html index.php</div><div class="line">&lt;/IfModule&gt;</div></pre></td></tr></table></figure>
<p>重启apache服务使更改生效：<br><code>sudo /etc/init.d/httpd restart</code></p>
<p>再之后，要拷贝php的配置文件：<br><code>cp ../php-5.2.10/php.ini.dist /usr/local/php/lib/php.ini</code></p>
<p>然后就可以进行验证了，在网络文件夹下建立info.php：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">phpinfo();</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure>
<p>接着打开浏览器，输入localhost/info.php<br>如果输出正常，那么配置就完成了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/11/24/c和c-面试常见问题总结/" itemprop="url">
                  c和c++面试常见问题总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-11-24T23:11:54+08:00" content="Nov 24 2014">
              Nov 24 2014
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/笔试面试/" itemprop="url" rel="index">
                    <span itemprop="name">笔试面试</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/11/24/c和c-面试常见问题总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/11/24/c和c-面试常见问题总结/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="c和c-面试常见问题总结"><a href="#c和c-面试常见问题总结" class="headerlink" title="c和c++面试常见问题总结"></a>c和c++面试常见问题总结</h1><h2 id="list-vector-set-map"><a href="#list-vector-set-map" class="headerlink" title="list vector set map"></a>list vector set map</h2><p>List封装了链表，vector封装了数组，list不支持下标操作，一个是离散存储，一个是连续存储。<br>set和map属于标准关联容器，使用的是高效的平衡检索二叉树：红黑树。插入删除效率高，因为不需内容拷贝和移动，只需直接替换指向节点的指针。<br>Set不包含重复的元素，hash_map用空间换了时间。</p>
<h2 id="template"><a href="#template" class="headerlink" title="template"></a>template</h2><p>包括函数模板和类模板。<br>类模板是允许用户为类定义一种模式，使得类中的某些数据成员、成员函数的参数、或成员函数的返回值能够取任意类型。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">template &lt;typename T&gt;</div><div class="line">inline const T&amp; maximum(const T&amp; x,const T&amp; y)&#123;</div><div class="line">  if(y &gt; x)</div><div class="line">      return y;</div><div class="line">  else</div><div class="line">      return x;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="static和const的区别"><a href="#static和const的区别" class="headerlink" title="static和const的区别"></a>static和const的区别</h2><ul>
<li>const就是只读的意思，只在声明中使用。static一般有两个作用，规定作用域和存储方式，对于局部变量，static规定其为静态存储方式，每次调用的初始值为上一次调用的值，调用结束后存储空间不释放。</li>
<li>对于全局变量，如果以文件划分作用域的话，此变量只在当前文件可见，对于static函数也是在当前模块内函数可见。</li>
<li>static的作用是把一个变量设置为静态。函数内部声明的static变量可作为对象间的一种通信机制。如果一个变量是类的一部分却不是该类的各个对象的一部分，就成为一个static静态成员。同理，一个需要访问类成员，而不需要针对特定对象去调用的函数，也被称为一个static成员函数。类的静态成员函数只能访问类的静态成员。</li>
<li>const是设置常量，也就是只读。</li>
</ul>
<h2 id="为什么函数加了static之后不能加virtual了："><a href="#为什么函数加了static之后不能加virtual了：" class="headerlink" title="为什么函数加了static之后不能加virtual了："></a>为什么函数加了static之后不能加virtual了：</h2><p>  因为静态成员函数可以不通过对象来进行调用，即没有隐藏的this指针。而virtual函数则一定需要通过对象来调用，即有隐藏的this指针。</p>
<h2 id="const-char-p-（char-const-p）和-char-const-p-有什么差别"><a href="#const-char-p-（char-const-p）和-char-const-p-有什么差别" class="headerlink" title="const char p （char const p）和 char * const p 有什么差别"></a>const char <em>p （char const </em>p）和 char * const p 有什么差别</h2><pre><code>const char *p 可对数组指向的任意位置做只读操作。char * const p 只能对某个固定的位置进行读写操作，定义了一个固定的地址，而且定义p的时候必须初始化。
</code></pre><h2 id="c的struct和c-的class有什么异同"><a href="#c的struct和c-的class有什么异同" class="headerlink" title="c的struct和c++的class有什么异同"></a>c的struct和c++的class有什么异同</h2><ul>
<li>相同处<ul>
<li>都是Contrainer类型，意味着都可以将其它类型作为成员</li>
<li>都可以有成员，所包括构造函数，方法，属性，域，常量，枚举，事件和事件Handler</li>
<li>成员可设成Public或Private</li>
<li>都可以实现接口</li>
</ul>
</li>
<li>不同处<ul>
<li>Structure是值类型，class是引用类型（返回类型）</li>
<li>structure的成员默认情况下是公共的，而Class的成员变量和常量默认情况下是私有的而其它成员默认情况下是公共的（默认成员属性）</li>
<li>structure必须至少有一个非共享的成员变量或事件成员，class可以完全是空的.</li>
<li>Structure的成员不能声明成Protected; class成员可以.</li>
</ul>
</li>
</ul>
<h2 id="值类型和引用类型的区别"><a href="#值类型和引用类型的区别" class="headerlink" title="值类型和引用类型的区别"></a>值类型和引用类型的区别</h2><pre><code>值类型是现金，要用直接用，引用类型是存折，得先取再用。     声明一个值类型变量，编译器会在栈上分配一个空间，这个空间对应着该值类型变量，空间里存储的就是该变量的值。引用类型的实例分配在堆上，新建一个引用类型实例，得到的变量值对应的是该实例的内存分配地址
</code></pre><h2 id="引用运算符和引用分别表示什么"><a href="#引用运算符和引用分别表示什么" class="headerlink" title="引用运算符和引用分别表示什么"></a>引用运算符和引用分别表示什么</h2><p>引用引入了对象的一个同义词，声明引用时必须对其进行初始化，引用本身不占用存储单元，它只是一个别名。引用一般有两个用途： 作为函数参数和从函数中返回左值。</p>
<ul>
<li>作为函数参数相当于是赋予了它返回值的能力，更改有效了</li>
<li>给函数传递大型对象时，使用引用也可以提高效率。（比如拷贝构造函数）</li>
<li>引用返回值</li>
<li>常引用 const &amp; 引用名=目标变量名 ，不能通过引用对目标变量进行修          改了。</li>
<li>利用引用产生多态效果： B是A的子类， B b； A &amp; Ref = b；那么ref只能用来访问派生类对象中从基类继承下来的成员，是基类引用指向派生类。如果A类中定义有虚函数，并且在B类中重写了这个虚函数，就可以通过Ref产生多态效果。（使用指针的话就是用基类指针指向子类的对象们），算是实现多态的两种方式吧。</li>
</ul>
<h2 id="C和C-的关系"><a href="#C和C-的关系" class="headerlink" title="C和C++的关系"></a>C和C++的关系</h2><ul>
<li>c++语言支持函数重载，c语言不支持。函数被c++编译后在库中的名字与c语言不同。提供extern “C”来解决名字匹配的问题。</li>
<li>c是一种结构化语言，重点在于算法和数据结构。 c程序的设计首先考虑的是如何通过一个过程，对输入进行运算处理得到输出。</li>
<li>c++首先考虑的是如何构造一个对象模型，让这个模型能够契合与之对应的问题域，这样就可以通过获取对象的状态信息得到输出或实现过程控制。</li>
</ul>
<h2 id="对于宏的理解"><a href="#对于宏的理解" class="headerlink" title="对于宏的理解"></a>对于宏的理解</h2><pre><code>#define 不能以分号结束，预处理器会帮你计算常数表达式的值，要把参数用括号括起来。
</code></pre><h2 id="const的主要用法有哪些？"><a href="#const的主要用法有哪些？" class="headerlink" title="const的主要用法有哪些？"></a>const的主要用法有哪些？</h2><ul>
<li>定义常量，修饰函数参数，修饰函数返回值， 在c++中还可以修饰函数的定义体。被const修饰的就是只读，防止意外的变动，提高程序的健壮性。</li>
<li>与#define定义常量相比，const常量有数据类型，而宏常量没有。编译器可以对前者进行类型安全检查，而对后者只是进行字符替换，没有类型安全检查。</li>
<li>使用调试工具可以对const常量进行调试，宏常量肯定不行。</li>
<li>在c++程序中，类里面的数据成员加上mutable之后，修饰为const的成员函数，就可以对其进行修改了。</li>
</ul>
<h2 id="各类的sizeof"><a href="#各类的sizeof" class="headerlink" title="各类的sizeof"></a>各类的sizeof</h2><ul>
<li>指针的4字节，每个字符1字节，每个int类型4字节，short 两个字节，long四个字节，struct注意要补空，float四个字节。空类所占空间1，虚继承的类涉及指针，大小为4.</li>
<li>sizeof和strlen的区别：<ul>
<li>sizeof操作符的结构类型是size_t, 它在头文件中的typedef为unsigned int类型，该类型保证能容纳实现所建立的最大对象的字节大小</li>
<li>sizeof是运算符，strlen是函数</li>
<li>sizeof可以用类型做参数，strlen只能用char* 做参数，而且必须以’\0’结尾</li>
<li>数组做sizeof的参数不退化，传递给strlen就退化为指针</li>
<li>数组作为参数传递给函数时传的是指针而不是数组，传递的是数组的首地址。在c++中传递数组永远都是传递指向数组首元素的指针</li>
</ul>
</li>
</ul>
<h2 id="内联函数和宏的差别是什么"><a href="#内联函数和宏的差别是什么" class="headerlink" title="内联函数和宏的差别是什么"></a>内联函数和宏的差别是什么</h2><ul>
<li>内联函数在编译的时候可以直接被镶嵌到目标代码中，而宏只是一个简单的替换</li>
<li>内联函数要做参数类型检查。</li>
<li>inline是指嵌入代码，对于短小的代码而言，这样可以带来效率提升，不过有一定的空间消耗，主要用于一个函数被重复调用而且函数只有简单几行的情况</li>
<li>宏是在代码处不加任何验证的简单替代，而内联函数是将代码直接插入调用处。</li>
</ul>
<h2 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h2><ul>
<li>非空区别：任何时候都不能使用指向空值的引用。一个引用必须总是指向某些对象。如果使用一个变量并让它指向一个对象，但是该变量在某些时候也可能不指向任何对象，这是应该把变量声明为指针。而当确定这个变量不可能指向空的时候，可以声明为引用，这意味着引用的代码效率比使用指针要高。</li>
<li>合法性区别：在使用引用之前不需要检测其合法性，而指针则总应该被测试，防止其为空。</li>
<li>可修改区别：指针可以被重新赋值以指向另一个不同的对象，但是引用总是指向初始化时被指定的对象，之后不能改变，但对象的内容可以被改变</li>
</ul>
<p>应用区别：以下情况应该使用指针：</p>
<ul>
<li>考虑到存在不指向任何对象的可能时</li>
<li>需要能够在不同时刻指向不同的对象时。 否则应该使用引用。</li>
</ul>
<h2 id="java和c-的区别"><a href="#java和c-的区别" class="headerlink" title="java和c++的区别"></a>java和c++的区别</h2><pre><code>java是完全的面向对象，封装、继承和多态。
</code></pre><ul>
<li>指针： java使用自动的内存管理功能，不同于c++的指针</li>
<li>多重继承： c++支持多重继承 允许许多父类派生一个类，。java不支持多重继承，但允许一个类继承多个接口（extends+implement）。</li>
<li>数据类型和类： java是完全面向对象的语言，所有的函数和变量都必须是类的一部分。除了基本的数据类型之外，其余的都作为类对象。而c++允许将函数和变量定义为全局的。</li>
<li>java自动内存管理，无需程序员删除</li>
<li>java不支持操作符重载</li>
<li>预处理功能 java不支持预处理</li>
</ul>
<h2 id="实参和形参的差别"><a href="#实参和形参的差别" class="headerlink" title="实参和形参的差别"></a>实参和形参的差别</h2><ul>
<li>形参出现在函数定义中，在整个函数体内都可以使用， 离开该函数则不能使用。</li>
<li>实参出现在主调函数中，进入被调函数后，实参变量也不能使用。 形参和实参的功能是作数据传送。发生函数调用时， 主调函数把实参的值传送给被调函数的形参从而实现主调函数向被调函数的数据传送。</li>
</ul>
<h2 id="指针数组和数组指针的差别"><a href="#指针数组和数组指针的差别" class="headerlink" title="指针数组和数组指针的差别"></a>指针数组和数组指针的差别</h2><ul>
<li>指针数组是一个数组里面装着指针</li>
<li>指向数组的指针，代表它是指针，指向整个数组。</li>
<li>空指针和迷途指针 delete之后内存虽然被释放但指针本身仍然存在。</li>
</ul>
<h2 id="malloc-free-和-new-delete的区别"><a href="#malloc-free-和-new-delete的区别" class="headerlink" title="malloc/free 和 new/delete的区别"></a>malloc/free 和 new/delete的区别</h2><p>对于非内部数据类型而言，malloc/free 无法满足动态对象的要求。对象在创建的时候要自动执行构造函数，在消亡之前要析构函数。由于 malloc/free是库函数而不是运算符，不在编译器控制权限内，因此需要一个能够完成动态内存分配和初始化工作的运算符new 以及完成清理和释放内存工作的运算符delete。 new/delete不是库函数，而是运算符。</p>
<h2 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h2><p>将现实世界的物抽象成对象。<br>     面向对象技术的基本概念必须提供对象 类 和继承<br>     三个特性 封装，多态和继承</p>
<ul>
<li>封装，类定义将其说明(用户可见的外部接口)与实现（用户不可见的内部接口）显示的分开了。</li>
<li>面向对象了之后具有良好的可复用性，易维护以及良好的扩充性。</li>
<li>必须使用静态成员函数在一个类的所有实例之间共享数据。如果想限制对静态成员的变量的访问，则必须把它们声明为保护型或私有型。</li>
</ul>
<h2 id="重载和覆盖有什么差别"><a href="#重载和覆盖有什么差别" class="headerlink" title="重载和覆盖有什么差别"></a>重载和覆盖有什么差别</h2><pre><code>覆盖是对成员函数的重写，而重载则是有着不同的参数列表或者参数类型的函数。重载的优点主要在于可以在一个类中定义功能类似的函数，属于静态绑定的范畴。    
</code></pre><h2 id="什么是虚函数，为什么需要虚函数-什么是多态"><a href="#什么是虚函数，为什么需要虚函数-什么是多态" class="headerlink" title="什么是虚函数，为什么需要虚函数 什么是多态"></a>什么是虚函数，为什么需要虚函数 什么是多态</h2><pre><code>多态就是一个接口，多种方法。在程序运行的过程中才决定调用的函数。多态性允许你将父对象设置成为和它的一个或更多的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特征以不同的方式运作。使用的时候先用父类指针指向子类型的对象，然后直接或间接使用基类指针调用虚函数，静态成员函数不能定义为虚函数因为它不用对象就可以访问，构造函数不能定义为虚函数，因为定义了没有意义因为构造函数不被继承。
</code></pre><h2 id="面向对象的主要思想是什么，什么是多态，为什么要有“多态”-“接口”。什么是好的面向对象设计，虚函数-多重继承，这是JAVA没有的，为什么JAVA没有的原因。"><a href="#面向对象的主要思想是什么，什么是多态，为什么要有“多态”-“接口”。什么是好的面向对象设计，虚函数-多重继承，这是JAVA没有的，为什么JAVA没有的原因。" class="headerlink" title="面向对象的主要思想是什么，什么是多态，为什么要有“多态”,“接口”。什么是好的面向对象设计，虚函数 多重继承，这是JAVA没有的，为什么JAVA没有的原因。"></a>面向对象的主要思想是什么，什么是多态，为什么要有“多态”,“接口”。什么是好的面向对象设计，虚函数 多重继承，这是JAVA没有的，为什么JAVA没有的原因。</h2><p>所谓“好的面向对象设计”是那些可以满足“应对变化，提高复用”的设计。面向对象三大机制的支持，即： “封装、继承、多态”。</p>
<ul>
<li>封装，隐藏内部实现</li>
<li>继承，复用现有代码</li>
<li>多态，改写对象行为</li>
</ul>
<h2 id="char与int的转换"><a href="#char与int的转换" class="headerlink" title="char与int的转换"></a>char与int的转换</h2><pre><code>char也是一种整型 从-128 到 127之间 与整型数其实有种一一对应的关系。
char到数字的话减去’0’
</code></pre><h2 id="A-copy-constructor-is-called-whenever-a-new-variable-is-created-from-an-object"><a href="#A-copy-constructor-is-called-whenever-a-new-variable-is-created-from-an-object" class="headerlink" title="A copy constructor is called whenever a new variable is created from an object."></a>A copy constructor is called whenever a new variable is created from an object.</h2><ul>
<li>拷贝构造；</li>
<li>深拷贝和浅拷贝的定义可以简单理解成：如果一个类拥有资源(堆，或者是其它系统资源)，当这个类的对象发生复制过程的时候，这个过程就可以叫做深拷贝，反之对象存在资源，但复制过程并未复制资源的情况视为浅拷贝, 在定义类的时候要写的一个函数，用来提供类的一份拷贝的功能。<br>   对对象的复制。that’s a copy of itself. 所做的事情包括复制常规的成员，复制指针的空间。</li>
</ul>
<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>为什么要运算符重载呢，那是因为c++预定义的运算符只是适用于基本的数据类型，对于许多用户自定义的类型（比如类）在需要类似的运算操作的时候就要自己进行定义了。其实质还是函数重载，提供了c++的可扩展性。</p>
<p>通过创建运算符函数实现，其定义了重载的运算符将要进行的操作。与其他函数的定义相比，运算符函数的函数名是由关键字operator和其后要重载的运算符符号构成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;返回类型说明符&gt;operator&lt;运算符符号&gt;（&lt;参数表&gt;）</div><div class="line"> &#123;</div><div class="line"> &lt;函数体&gt;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>可以选择把重载函数定义为成员函数或者是非成员的友元函数，如果定义为成员函数，那么参数列表中会少一个，因为可以用this指针隐式的访问类的一个对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">bool operator&lt;(const test &amp;t1) const&#123;</div><div class="line">    return (v &lt; t1.v);//第一个v应该是this指针隐式访问的。</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>友元函数：比较一个int对象和类对象的大小。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">    friend inline bool operator&lt;(const int &amp;a, const test &amp; t1)&#123;</div><div class="line">    return (a &lt; t1.v);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="对一个类的拷贝构造函数，赋值运算符到底是传值还是传引用，怎么返回？返回值还是引用。"><a href="#对一个类的拷贝构造函数，赋值运算符到底是传值还是传引用，怎么返回？返回值还是引用。" class="headerlink" title="对一个类的拷贝构造函数，赋值运算符到底是传值还是传引用，怎么返回？返回值还是引用。"></a>对一个类的拷贝构造函数，赋值运算符到底是传值还是传引用，怎么返回？返回值还是引用。</h2><ul>
<li>比如String &amp; String::operate=(const String &amp;other)的const是干嘛的？</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">MyString s3(pello)</div><div class="line">const MyString s4(qello)</div><div class="line">s3=s4</div></pre></td></tr></table></figure>
<ul>
<li><p>除非使用const，否则就会出错。一个const常量不能随意转化成非const常量。<br>   或者</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">MyString s7（adf）；</div><div class="line">MyString s8（adf）；</div><div class="line">MyString s9（adf）；</div><div class="line">s9 = s8 + s7</div></pre></td></tr></table></figure>
<p>   不用const也会报错，因为+赋值必须返回一个操作值已知的MyString对象。</p>
</li>
</ul>
<h2 id="x是否为2的若干次幂的判断"><a href="#x是否为2的若干次幂的判断" class="headerlink" title="x是否为2的若干次幂的判断"></a>x是否为2的若干次幂的判断</h2><p><code>cout &lt;&lt; boolalpha &lt;&lt; ((i &amp; (i – 1)) ? false : true) &lt;&lt; endl;</code></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/11/24/mysql反模式-5-第四部分应用程序开发反模式/" itemprop="url">
                  mysql反模式(5)--第四部分应用程序开发反模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-11-24T00:17:26+08:00" content="Nov 24 2014">
              Nov 24 2014
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/11/24/mysql反模式-5-第四部分应用程序开发反模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/11/24/mysql反模式-5-第四部分应用程序开发反模式/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="MySQL反模式（5）-–-第四部分-应用程序开发反模式"><a href="#MySQL反模式（5）-–-第四部分-应用程序开发反模式" class="headerlink" title="MySQL反模式（5） – 第四部分 应用程序开发反模式"></a>MySQL反模式（5） – 第四部分 应用程序开发反模式</h1><p>如总纲中所说，SQL肯定是与多种编程语言构建的应用程序结合然后加以使用的。在应用程序中使用SQL的方式有好有坏，这部分内容描述了一些常见错误。主要的章节安排如下：</p>
<ol>
<li>第20章 明文密码 – 这一章主要描述在需要恢复或重置密码的场景下，如何规避不正确的密码存储方式可能带来的密码泄露的风险。</li>
<li>第21章 SQL注入 – 在常见的SQL动态查询中，必须找到能够有效避免SQL注入的方式。</li>
<li>第22章 伪键洁癖 – 本章的内容不那么重要，有些人会为了主键id不连续而抓狂，这一章主要探讨了这方面的问题。</li>
<li>第23章 非礼勿视 – 在进行sql查询的时候，经常会返回各类错误，如果正确的定位，从而提高程序健壮性是必须考虑的问题。</li>
<li><p>第24章 外交豁免权 – 很多时候，不好的编程习惯会给我们带来沉重的技术债务。对于SQL来说更甚，因为很多人都没有把它当做一门编程语言！</p>
</li>
<li><p>第25章 魔豆 – 正确的理解MVC模型，有助于我们更好、更清晰的使用SQL。</p>
</li>
</ol>
<h2 id="第20章-明文密码"><a href="#第20章-明文密码" class="headerlink" title="第20章 明文密码"></a>第20章 明文密码</h2><p>这一章的目标是正确合理的存储密码，从而方便的能够恢复或重置密码。</p>
<p>主要问题:<br>一个致命的设计是，使用明文存储密码。这些信息在网络上传输的时候非常不安全。可能有几种方式能够获得密码：</p>
<ul>
<li>在客户端和服务器端数据库交互的网络线路上截获数据包 – wireshark</li>
<li>在数据库服务器上搜索SQL的查询日志 – 前提是已侵入数据服务器</li>
<li>从服务器或者备份介质上读取数据库备份文件内的数据</li>
<li>而在验证密码的时候，最好能够区分到底是密码错了还是用户名根本就不存在这两种场景。这样程序逻辑可以显得更加用户友好一些。</li>
</ul>
<p>将明文密码通过e-mail发送是非常大的安全隐患，因此为了规避这一问题，使用明文存储密码的方案是完全不可行的。</p>
<ol>
<li>解决方案：先哈希，后存储</li>
</ol>
<p>哈希函数将输入的字符串转化成另一个新的不可识别的字符串，同时，哈希算法不可逆。一个号的哈希算法应该需要花上和直接猜测密码差不多的工作量才能找到原始串。</p>
<p>SHA-1算法已经可以破解，至少使用SHA-256的加密算法还是一个比较靠谱的选择。MD5也是比较弱的加密，慎用。</p>
<p>可以采用SQL自带的哈希函数，但这并不是标准的SQL语言。比如： INSERT </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">INTO Accounts (account_id,account_name,tmail,password_hash) VALUES (123,&apos;billkarwin&apos;,&apos;bill@example.com&apos;,SHA2(&apos;xyzzy&apos;));</div></pre></td></tr></table></figure>
<p>为了进一步提高安全性，有必要给哈希加料。因为黑客还是有可能通过字典攻击的方法通过尝试的方式来破解现有用户的密码。加料的方式就是在进入哈希函数加密之前，通过连接一个无意义的串，来增加破解难度。</p>
<p>作料的合理长度应该是8个字节，需要为每个密码生成作料。最好是随机生成的。</p>
<p>同时，为了避免密码在传输过程中被截获，应该在接收请求的server逻辑中就进行密码的加密工作。而从浏览器到后端服务器之间的这段传输，则只能通过https的方式进行加密了。</p>
<ol>
<li>重置密码，而不是恢复密码</li>
</ol>
<p>尽管密码已经以一种更安全的方式被存储了，但是还需要解决最原始的问题：找回密码。</p>
<p>第一个方案是当用户忘记他们的密码请求帮助的时候，程序发送一封带有临时生成密码的邮件给用户，而不是直接发给他们密码。同时程序应该设计成一旦用户使用临时密码登陆后，就应该被强制要求修改密码。<br>第二个方案，在数据库中记录下这个请求，并且为其分配一个唯一的令牌作为标识，而不是发送带有新密码的邮件。用户在重置密码时，必须带上这个标识。<br>如果密码对你可读，那对攻击者也是如此。</p>
<h2 id="第21章-SQL注入"><a href="#第21章-SQL注入" class="headerlink" title="第21章 SQL注入"></a>第21章 SQL注入</h2><p>SQL动态查询是指将程序中得变量和基本SQL语句拼接成一个完整的查询语句。而如果你将未经验证的输入作为代码来执行的话，那么SQL注入就很难避免了。</p>
<p>最常见的sql注入就是单引号，比如名字中包含单引号，那么SQL语句执行时就可能出错。</p>
<p>下面这个例子更加高级一些：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$sql = &quot;UPDATE Accounts SET password_hash = SHA2(&apos;$password&apos;) </div><div class="line"></div><div class="line">WHERE account_id=$userid;&quot;</div></pre></td></tr></table></figure>
<p>假如请求的url如下：</p>
<p><a href="http://bugs.example.com/setpass?password=xyzzy$userid=123" target="_blank" rel="external">http://bugs.example.com/setpass?password=xyzzy$userid=123</a> OR TRUE</p>
<p>那么基本上你对用户名的校验就要失效了。SQL注入是通过在SQL语句被数据库解析之前，以修改其语法的形式工作的。只要你在解析语句之前插入动态部分，就存在SQL注入的风险。</p>
<p>解决方案：不信任任何人</p>
<p>过滤输入内容</p>
<p>将所有不合法字符剔除，可以使用filter扩展指定数字：</p>
<p>$bugid = filter_input(INPUT_GET,”bug_id”,FILTER_SANITIZE_NUMBER_INT);</p>
<p>或者简单的就直接用intval这种取数字的函数好了。</p>
<p>同时通过正则表达式来匹配安全的子串也是不错的选择。</p>
<p>参数化动态内容</p>
<p>对于一些简单地类型，应该使用查询参数将其和SQL表达式分离。这对于那些字符串的类型尤其适用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line"></div><div class="line">$sql = &quot;UPDATE Accounts SET password_hash = SHA2(?) WHERE account_id = ?&quot;;</div><div class="line"></div><div class="line">$stmt = $pdo-&gt;prepare($sql);</div><div class="line"></div><div class="line">$params = array($_REQUEST[&apos;password&apos;],$_REQUEST[&apos;userid&apos;]);</div><div class="line"></div><div class="line">$stmt-&gt;execute($params);</div><div class="line"></div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<p>给动态输入的值加引号</p>
<p>很多时候，查询参数的方式有可能会导致查询优化器无法正确选择使用哪个索引进行优化。比如某一列is_flag，可能99%的数据都是true，1%为false，那么如果使用查询参数的方式，那么优化器不知道你会传入哪个，因此很有可能选择错误的优化方案。</p>
<ol>
<li>将用户与代码隔离</li>
</ol>
<p>假如说你的界面需要用户选择排序方式，那么不要让用户直接输入怎么排列的数据。而是给用户一些状态，然后再这些状态和sql语句需要的真实值之间做一个映射关系。如果用户输入不在此范围内的话，当然要提供一些默认值了。</p>
<p>这种做法优势颇多： </p>
<ul>
<li>从不将用户的输入与SQL查询语句连接，因此减少了SQL注入的风险 </li>
<li>可以让SQL语句中得任意部分变得动态化，包括标识，SQL关键字，甚至整句表达式 </li>
<li>使用这个方法验证用户的输入变得简单而高效 </li>
<li>能将数据库查询的细节和用户界面解耦</li>
</ul>
<ol>
<li>找个可靠的人帮你code review</li>
</ol>
<p>找出所有使用了程序变量、字符串链接或者替换等方法组成的SQL语句<br>跟踪在SQL语句中使用的动态内容的来源<br>假设任何外部内容都是潜在威胁<br>让用户输入内容，千万别让用户输入代码。</p>
<h2 id="第22章-伪键洁癖"><a href="#第22章-伪键洁癖" class="headerlink" title="第22章 伪键洁癖"></a>第22章 伪键洁癖</h2><p>事实上，这一章存在的意义是为了劝服那些觉得主键一定要连续的强迫症们，这样的抵抗完全是费力二不讨好的。 所以建议就是，就这么用吧。如果真的想要连续，那就自己定义有意义的连续的自然键好了。</p>
<h2 id="第23章-非礼勿视"><a href="#第23章-非礼勿视" class="headerlink" title="第23章 非礼勿视"></a>第23章 非礼勿视</h2><p>每个有追求的程序员都想写出优雅的代码，另一类有追求的程序员会删掉所有那些他们觉得冗余的代码。</p>
<p>但是很多时候，删的太多容易造成两种“非礼勿视”：</p>
<p>忽略数据库API的返回值：相信代码肯定不会出问题。<br>和程序代码混在一起阅读那些分散的SQL语句片段：不把完整的SQL打印出来，很多时候很难看出问题。<br>因此很多时候，必须让程序能够从错误中恢复，从而更加健壮：</p>
<ul>
<li>检查数据库API返回状态和异常</li>
<li>使用实际的SQL查询语句来进行调试</li>
<li>使用变量记录sql语句</li>
<li>打印出来</li>
<li>千万别把SQL语句当做html注释一起输出在页面上<br>所以</li>
</ul>
<p>发现并解决代码中得问题已经很困难了，就别再盲目的干了。。</p>
<h2 id="第24章-外交豁免权"><a href="#第24章-外交豁免权" class="headerlink" title="第24章 外交豁免权"></a>第24章 外交豁免权</h2><p>有的时候总会遇到前人留下来要接手的项目，这些项目往往背负着虫虫的技术债务。这都是由于使用了捷径而不是最佳实践的后果。技术债务会不断给项目带来风险和额外的工作，知道你重构、测试并为代码编写文档。</p>
<p>好的习惯大家都知道： </p>
<ul>
<li>将源代码使用版本控制工具管理起来，比如SVN或Git </li>
<li>为程序编写自动化测试脚本或者功能测试脚本 </li>
<li>编写文档，规格说明以及代码注释来记录程序的需求和实现机制</li>
</ul>
<p>但是问题是，很多人都不把SQL当做编程语言。有可能软件工程师和dba是分开的，有可能SQL跟别的语言差别比较大，有可能SQL没有IDE。原因众多，但是这都不是不正视SQL语言的理由。</p>
<p>要想判断代码是不是临时，唯一标准就是使用之后能不能立刻删。</p>
<p>质量对于大多数程序来说就是测试，但是这只是质量控制，保证质量需要：</p>
<ul>
<li>清晰定义项目需求，写成文档</li>
<li>SQL文档中最好包含以下部分：</li>
<li>实体关系图</li>
<li>表、列及视图</li>
<li>关系</li>
<li>触发器</li>
<li>存储过程</li>
<li>SQL安全</li>
<li>数据库基础设施</li>
<li>设计并实现解决方案来满足需求</li>
<li>源码必须进行版本控制</li>
<li>数据定义脚本</li>
<li>初始数据</li>
<li>触发器和存储过程</li>
<li>验证并测试解决方案符合需求</li>
</ul>
<p>##第25章 魔豆</p>
<p>MVC模型在web开发中使用的如此普遍，以至于随处可见。但是很多时候，界线的模糊会导致分工不明确，反而会失去它原有的逻辑分离的优势。</p>
<p>控制器：接受用户输入，定义响应逻辑，委托模型操作，再返回视图 模型：程序核心，输入验证、业务逻辑、数据库交互 视图：用户界面展示信息</p>
<p>简单地程序中，模型不会被定义很多逻辑，它更多的会被作为一个数据库中某个表的映射对象来使用（ORM）。又称为活动记录。这种做法没错，但是并不适用于所有场景。</p>
<p>有一个有趣的概念叫做抽象泄露：</p>
<blockquote>
<p>抽象简化了一些技术的内部工作原理并且让其更加方便调用。但当由于需要更高效的生产效率而不得不了解内部细节的时候，就称之为抽象泄露。</p>
</blockquote>
<p>一般出现这种情况的时候，就会产生，还不如当初不用简单模型的感慨。</p>
<p>当太多的活动记录出现，而逻辑集中在控制器层的时候，引用关系会十分混乱。活动记录太过于低层，控制器需要关注太多这种数据操作层面的代码。而且很多冗余的情况也都会出现。 同时，想要单元测试也十分的困难，因为点太多了！</p>
<p>唯一合理的场景是：你只需要CRUD操作。</p>
<p>因此，模型不应该仅仅承载活动记录这一种功能。它必须：</p>
<ul>
<li>信息专家： 一个对象应该有所有需要的数据来满足他所负责的操作，模型和活动记录之类的DAO关系应该是HAS-A而不是IS-A的关系。</li>
<li>创造者：一个模型如何维护数据库应该是它的内部实现细节，不许关系</li>
<li>低耦合：必须解耦程序</li>
<li><p>高内聚：模型接口应该反映出他所期望的调用方式，而不是数据库物理结构或者CRUD操作。<br>模型是实现程序业务逻辑的地方，将数据存储在数据库中是模型的内部实现细节。经过对模型的改造之后：</p>
</li>
<li><p>各类之间必将解耦</p>
</li>
<li>控制器代码大大简化</li>
<li>控制器无需了解DAO数据内部细节，只关心用户输入，然后调用API。</li>
</ul>
<p>在与mysql相关的应用程序开发中，经常会遇到各种各样的坑，如何很好地避免这些坑，选取最合适的开发方式。并及时偿还技术债务，这一部分给出了很好地阐释。</p>
<p>总体来看，这本书的观点更为传统，有些部分看起来可能还略显啰嗦。但是其可贵之处在于认真与严谨、用事实说话、和不拘泥思路的解决问题。从这上面得到的启发与技术上得进步，可以并驾齐驱了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/11/24/mysql反模式-4-第三部分查询反模式/" itemprop="url">
                  mysql反模式(4)--第三部分查询反模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-11-24T00:08:53+08:00" content="Nov 24 2014">
              Nov 24 2014
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/11/24/mysql反模式-4-第三部分查询反模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/11/24/mysql反模式-4-第三部分查询反模式/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="mysql反模式-4-–-第三部分-查询反模式"><a href="#mysql反模式-4-–-第三部分-查询反模式" class="headerlink" title="mysql反模式(4)– 第三部分 查询反模式"></a>mysql反模式(4)– 第三部分 查询反模式</h1><p>这一部分主要集中讨论了一下，在查询数据时应该注意的问题。</p>
<p>主要章节如下：</p>
<ol>
<li>第14章 对未知的恐惧 – 必须正确意识到何时以及如何正确的使用NULL</li>
<li>第15章 模棱两可的分组 – 如何使用正确的方式获取每组的最大值 </li>
<li>第16章 随机选择 – 讨论如何正确的从一个大的数据集中返回一些数据样例</li>
<li>第17章 可怜人的搜索引擎 – 使用SQL实现数据库搜索的需求</li>
<li>第18章 意大利面条式查询 – 必须尽可能的减少SQL查询量从而降低复杂度</li>
<li>第19章 隐式的列 – 如果你选择通配符这种鸵鸟战术，那么可能你select出来的到底是什么都不知道</li>
</ol>
<p>##第14章 对未知的恐惧<br>本章的目标是辨别悬空值。</p>
<p>有很多在SQL的表盒查询中有效使用空值的途径：</p>
<ul>
<li>可以在添加一条记录时，使用NULL代替那些还不确定的值</li>
<li>一个给定的列如果没有合适的值，可以在对应的行中适应NULL</li>
<li>当传入的参数无效时，一个函数的返回值也可以是NULL,如DAY(2014-12-32)</li>
<li>外联结查询中，NULL被用来当做未匹配的列的占位符<br>反模式是将NULL作为普通的值，需要注意的是，NULL与0、false或空字符串都是不同的。而在查询时，以下语句都不会返回包含NULL的列：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SELECT * FROM table_a WHERE column_a = 1;</div><div class="line">SELECT * FROM table_a WHERE NOT (column_a = 1);</div></pre></td></tr></table></figure>
<p>同时，与NULL的直接比较都不会返回任何结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SELECT * FROM table_a WHERE column_a = NULL;</div><div class="line">SELECT * FROM table_a WHERE column_a &lt;&gt; NULL;</div></pre></td></tr></table></figure>
<p>有的开发人员可能会觉得NULL非常的麻烦，试图通过声明NOT NULL的方式解决这个问题，但是事实上，你必须保证列中的每一个值都有意义才可以这么做。</p>
<p>在将NULL视为特殊值之后，就需要利用特殊操作符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SELECT * FROM table_a WHERE column_a IS NULL;</div><div class="line">SELECT * FROM table_a WHERE column_a IS NOT NULL;</div></pre></td></tr></table></figure>
<p>另外一种避免NULL带来麻烦的方法就是声明默认值DEFAULT. 当然这很大程度上你的列意义中是否存在这样的一个默认值。</p>
<p>如果想要强制让某一列或某个表达式返回非NULL的值，可以借助COALESCE()函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT  CONCAT( COALESCE(firstName,&apos; &apos;), lastName) As fullName FROM Accounts;</div></pre></td></tr></table></figure>
<p>##第15章 模棱两可的分组<br> 很多时候都会用到查询时使用GROUP BY的场景，用来对分组多行记录使用一些聚合函数，或是每组获取一条统计记录等。它的强大之处在于，将复杂的报表生成过程简化到只用相对很少的代码。</p>
<p>尽管group by很强大，但是针对我们想要返回每组最大值的查询，同时也能返回这个值对应的记录的其他字段。这类需求，就比较难以满足了。</p>
<p>原因在于SQL中分组查询逻辑的特殊性：</p>
<p>单值规则：属于每个组的行，它们的GROUP BY关键字所指定的那些列中得值都是一样的,对于每个不同的FID都会返回一条记录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SELECT FID, MAX(createTime) AS latest </div><div class="line">FROM table1 join table2 USING (commen_id)</div><div class="line">GROUP BY FID;</div></pre></td></tr></table></figure>
<p>但是下面这个语句无法保证：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SELECT FID, MAX(createTime) AS latest,common_id </div><div class="line">FROM table1 join table2 USING (common_id)</div><div class="line">GROUP BY FID;</div></pre></td></tr></table></figure></p>
<p>因为一个FID可能对应多个common_id，这会导致数据库查询的错误。</p>
<p>注意，distinct也能达到对查询结果去重的目的，保证最终返回的每一行都唯一,表Bugs描述了bug提出的日期和提出人等信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">SELECT DISTINCT date_reported,reported_by FROM Bugs;</div><div class="line">SELECT date_reported,reported_by FROM Bugs </div><div class="line">GROUP BY date_reported,reported_by;</div><div class="line">``` </div><div class="line"> 为了能够实现无歧义的使用列，存在几种方案：</div><div class="line"></div><div class="line">* 只查询功能依赖的列：</div><div class="line">所谓功能依赖是指一种确定的1v1 的关系，如果可以保证这一点，那就可以放心的使用GROUP BY了</div><div class="line">* 使用关联子查询：</div><div class="line">* 通过引用外联结查询，来保证返回的bug_id的唯一性：</div></pre></td></tr></table></figure>
<p>SELECT bp1.product_id,b1.date_reported AS latest, b1.bug_id<br>FROM Bugs b1 JOIN BugsProducts bp1 USING (bug_id)<br>WHERE NOT EXISTS<br> (SELECT * FROM Bugs b2 JOIN BugsProducts bp2 USING (bug_id)<br>  WHERE bp1.product_id = bp2.product_id<br>      AND b1.date_reported &lt; b2.date_reported);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"> 但是显然这个方法的查询性能不是最好，需要对美一条记录都执行一遍关联的子查询。</div><div class="line"></div><div class="line">使用衍生表：</div><div class="line">先得到临时结果，只包含product_id和其对应的最新的Bug报告日期。然后使用这个临时表和原表进行联结查询，然后即可得到每个产品的最新Bug信息。</div><div class="line">使用JOIN</div></pre></td></tr></table></figure></p>
<p>SELECT bp1.product_id, b1.date_reported AS latest, b1.bug_id<br>FROM Bugs b1 JOIN BugsProducts bp1 ON (b1.bug_id = bp1.bug_id)<br>LEFT OUTER JOIN (Bugs AS b2 JOIN BugsProducts AS bp2 ON (b2.bug_id = bp2.bug_id))<br>     ON (bp1.product_id = bp2.product_id AND (b1.date_reported &lt; b2.date_reported))<br>     OR b1.date_reported = b2.date_reported AND b1.bug_id &lt; b2.bug_id))<br>WHERE b2.bug_id IS NULL;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">必须找到date_reported为最大的bug的bug_id，如果date_reported相同，就选择bug_id最小的bug. </div><div class="line">JOIN解决方案适用于针对大量数据查询并且可伸缩性比较关键时，尽管难于理解和维护，但是能比基于子查询的解决方案更好地适应数据变化，一定要对不同类型的查询的性能进行实际测量，而不是仅靠猜测来判断哪个更好。</div><div class="line">通过对额外的列使用聚合函数：</div></pre></td></tr></table></figure></p>
<p>SELECT product_id, MAX(date_reported) AS latest<br>    MAX(bug_id) AS latest_bug_id<br>FROM Bugs JOIN BugsProducts USING (bug_id)<br>GROUP BY product_id;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">只有确定bug_id对应的bug的日期也是最新的时候，才可以使用这个方案，否则返回的结果就对不上了。 </div><div class="line"></div><div class="line">通过上述的论述可以看出，在查询，尤其是分组查询的时候，必须严格的遵守单值规则，从而避免获得模棱两可的查询结果。同时面对不同查询方法的选择，必须经过性能实际测量来确定，而非简单地猜测。</div><div class="line"></div><div class="line">## 第16章 随机选择</div><div class="line">在很多场景中，我们都需要从数据库中拉取一条随机数据，然后进行web展示。注入轮流展示的广告或是推荐的新闻、待审核记录的子集、测试数据等等。</div><div class="line"></div><div class="line">那么如何有效的获取样本数据，同时又能够保证较高的性能和较低的复杂度，是这一章主要讨论的问题。</div><div class="line"></div><div class="line">最常见的方式，是对查询记过进行随机排序，然后获取第一行：</div><div class="line"></div><div class="line">```SELECT * FROM Bugs ORDER BY RAND() LIMIT 1;</div></pre></td></tr></table></figure></p>
<p>尽管很流行，但是弱点明显：</p>
<ul>
<li>注意一般的order by可以充分利用索引的好处，但是使用RAND意味着整个排序过程无法利用索引。没有索引会基于随机函数返回的值。所以性能有问题，相当于一次全表遍历。</li>
<li>同时另一个问题是，好不容易排序好了，但绝大多数结果都浪费了。因为需要的只不过是一行而已。<br>当然，在数据量比较小得时候，这种方式毫无问题，比如随机产生中国所有省市中得一个。</li>
</ul>
<p>为了解决这一性能问题：</p>
<ul>
<li>从1到最大值之间随机选择：生成一个1到最大主键之间的随机数，但是必须保证主键连续。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">SELECT b1.*</div><div class="line">FROM Bugs AS b1</div><div class="line">JOIN (SELECT CEILT(RAND() * (SELECT MAX(bug_id) FROM Bugs)) AS rand_id) AS b2</div><div class="line">    ON (b1.bug_id = b2.bug_id);</div></pre></td></tr></table></figure>
<ul>
<li>选择下一个最大值：解决了1到最大值之间有间隙的情况，</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">SELECT b1.*</div><div class="line">FROM Bugs AS b1</div><div class="line">JOIN (SELECT CEIL(RAND()*(SELECT MAX(bug_id) FROM Bugs)) AS bug_id) AS b2</div><div class="line">WHERE b1.bug_id &gt;= b2.bug_id</div><div class="line">ORDER BY b1.bug_id</div><div class="line">LIMIT 1;</div></pre></td></tr></table></figure>
<p>但在间隙后的那个值被选中的概率会增大，当队列中间隙不大并且每个值要被等概率选中的重要性不高时，可以选择折中方案</p>
<ul>
<li>获取所有键值，随机选择一个：<br>用程序代码获取所有键值，然后随机选择一个<br>但是列表可能过长，而且要查询两次。<br>所以适用于逻辑简单且数据量湿度的时候。它在处理非连续值时很好。</li>
<li>使用偏移量选择随机行<br>计算总得数据行数，然后随机选择0-总行数之间的一个值。<br>当无法保证逐渐联系，而且需要每行被选中概率相同时，可以使用这个方案<br>本章中，提供了适应不同场景的诸多生成随机记录的方法，如何选择，就要视实际情况而定了。</li>
</ul>
<h2 id="第17章-可怜人的搜索引擎"><a href="#第17章-可怜人的搜索引擎" class="headerlink" title="第17章 可怜人的搜索引擎"></a>第17章 可怜人的搜索引擎</h2><p>SQL中，想要实现全文搜索非常困难，因为它根本就没有为此设计。sql一列中的的那个数据都是原子性的，因此比较两个值时通常都是两个整体，像like这种操作简直就是灾难。</p>
<p>它不受益于索引，同时其简单地匹配模式也使得很多场景下并不适用。唯一的场景就是，你的需求非常小，且不在乎索引。</p>
<p>最好的解决方案，就是让SQL做自己的事情，而把搜索交给专业的工具去做。这能够极大的减少重复的搜索开销。</p>
<ul>
<li>数据库扩展<br>MYSQL为MyISAM存储引擎提供了一个简单地全文索引类型。可以在一个类型为CHAR、VARCHAR或者TEXT列上定义一个全文索引。</li>
</ul>
<p><code>ALTER TABLE Bugs ADD FULLTEXT INDEX  bugfts</code><br>(summary,description);<br>检索时：</p>
<p><code>SELECT * FROM Bugs WHERE MATCH(summary,description) AGAINST (‘crash’);</code></p>
<p>Mysql 4.1之后同时还提供更精确的过滤方式：</p>
<p><code>SELECT * FROM Bugs WHERE MATCH(summary,description)
    AGAINST (‘+crash -save’ IN BOOLEAN MODE);</code><br> ORACLE、Microsoft SQL Server、PostgreSQL、SQLite都提供相应地搜索类型，这里不详细展开了。</p>
<ul>
<li>第三方搜索引擎<br>Sphinx Search<br>作为一个用于MySQL及PostgreSQL的开源搜索引擎，它构建索引和搜索都很快，并且支持分布式查询。对于数据不常更新且要求高可扩展性的程序来说是一个很好地选择。<br>通过配置sphinx的conf文件，可以指定构建索引的数据库。之后需要写一个SQL脚本获取数据从而构建索引。<br>以下给出配置文件的例子，最后一句指定从表中获取全量数据的语句：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">source bugsrc</div><div class="line">&#123;</div><div class="line">    type              = mysql</div><div class="line">    sql_user              = bugsuser</div><div class="line">    sql_pass              = password</div><div class="line">    sql_db           = database</div><div class="line">    sql_query      = \</div><div class="line">        SELECT bug_id,status,date_reported,summary,description \</div><div class="line">        FROM Bugs</div><div class="line">    sql_attr_timestamp = date_reported</div><div class="line">    sql_query_info       = SELECT * FROM Bugs WHERE bug_id=$id </div><div class="line">&#125;</div><div class="line"></div><div class="line">index bugs </div><div class="line">&#123;</div><div class="line">    source     = bugsrc</div><div class="line">    path        = /opt/local/var/db/sphinx/bugs</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 在shell中进行索引创建后，就可以搜索了：</p>
<p>indexer -c sphinx.conf bugs<br>search -b “crash -save”<br>它同时也提供守护进程和对应的API常用的脚本语言，但是最主要问题是它不支持高效的增量更新。</p>
<p>Apache Lucene<br>lucene是针对java的成熟搜索引擎。</p>
<p>它使用独有格式为文本文档创建索引，更新数据时也需要更新索引。lucene给你的自由度非常大，它不会直接从数据库读取数据，必须手动写入集合。而检索式，就可以使用java api了。而更棒的是apache的另一个项目：solr。它是lucene索引的网关服务，可以向solr添加文档或是使用REST风格的接口提交查询请求，然后就可以使用任意语言进行调用了。</p>
<p>看过这么多的解决搜索问题的方案，我想说的时，你完全没有必要使用SQL来解决所有的问题。</p>
<h2 id="第18章-意大利面条式查询"><a href="#第18章-意大利面条式查询" class="headerlink" title="第18章 意大利面条式查询"></a>第18章 意大利面条式查询</h2><p> 开发人员经常遇到一个很困扰的问题，那就是“我要怎么用一个查询来完成这件事情”。这本身，就是一个怪圈。</p>
<p>尽管sql极具表现力，可以在单个sql查询或单条语句完成很多事情，但是不意味着必须强制只使用一行代码。<br>通过一个查询来获得所有结果明显的副作用就是得到了一个笛卡尔积。这个结果往往是错误的，这也是一个最常见的错误。<br>不要尝试做一个类似于双重任务的查询，很多时候容易得到一个意料之外的笛卡尔积。<br>除了会得到错误的结果之外，这些查询也非常的难写、难以修改和难以调试。</p>
<p>由于其实SQL并没有那么难，所以如果你和单条SQL查询纠结了很长时间，那么应该重新考虑你的实现方式。<br>在这种场景下，最好的方式是遵循简约律：</p>
<blockquote>
<p>当你有两个相互竞争的理论能得出同样的结论，那么简单地那个更好。</p>
</blockquote>
<p>必须对已有的复杂的SQL语句进行分拆。<br>拆完之后查询不会产生早先例子里地笛卡尔积，因此很简单就能确认查询给出的结果准确<br>当有新的需求加进来的时候，加上另一个简单地查询，比将更多计算整合到一个很复杂的查询中要简单很多<br>sql引擎能更容易和可靠地对简单查询进行优化和执行。即使整个工作看上去像是被分割出来的查询弄的有点重复，但可能执行的更快<br>code review也更加方便<br>如果想要一次性返回结果，那么可以通过UNION操作的方式。</p>
<p>使用union操作之后，查询结果是每个子查询联合后得到的，但是要加上额外的一列来标识不同子查询的结果。<br>仅在两个子查询的列属性是相互兼容的情况下才能使用union，不能在查询的中间改变列的数值、名字或数据类型，需要确保所有行的所有列都是相同的。</p>
<p>还有一种可行的方式是用sql生成sql：<br>代码生成：自动的脚本<br>不要太专注于使用单个SQL语句解决复杂的问题：脚本很多时候是很好地替代选择。<br>执行多次SQL查询或多条SQL语句可能并不是解决问题最高效的方法，但你应该在效率和解决问题之间找到平衡点。</p>
<p>所以从本章中得出的最重要的结论就是：尽管SQL支持用一行代码解决复杂的问题，但也别做不切实际的事情。</p>
<h2 id="第19章-隐式的列"><a href="#第19章-隐式的列" class="headerlink" title="第19章 隐式的列"></a>第19章 隐式的列</h2><p>本章的目标是在写SQL语句时减少输入，很多程序员在查询的时候都是使用通配符的。但是这种捷径很可能会让你迷失方向。</p>
<ul>
<li>破坏代码重构：一旦数据表结构发生变化，以前通配符写得语句都完蛋了</li>
<li><p>隐藏的开销：在查询中使用通配符可能会影响性能和扩展性，一次查询所获取的列越多，客户端程序和数据库之间的网络传输的字节数也越多。<br>因此，解决的方案也很明显：</p>
</li>
<li><p>明确列出列名，而不是使用通配符或者隐式列的列表<br>这非常值得，因为：</p>
<ul>
<li>如果某一列位置被移动过，不会影响现有程序</li>
<li>如果新加入一列，不出现在当前结果中</li>
<li>如果删除，查询会得到告警的错误，这会早暴露出错误。</li>
</ul>
</li>
</ul>
<p>所以，通配符，还是少用的比较好。</p>
<p>这一部分罗列出了数据库查询时可能遇到的各种场景，对于实际使用还是有一些借鉴意义的。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/11/23/mysql反模式-3-第二部分物理数据库设计反模式/" itemprop="url">
                  mysql反模式(3)--第二部分物理数据库设计反模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-11-23T23:58:27+08:00" content="Nov 23 2014">
              Nov 23 2014
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/11/23/mysql反模式-3-第二部分物理数据库设计反模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/11/23/mysql反模式-3-第二部分物理数据库设计反模式/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="mysql反模式（3）–-第二部分-物理数据库设计反模式"><a href="#mysql反模式（3）–-第二部分-物理数据库设计反模式" class="headerlink" title="mysql反模式（3）– 第二部分 物理数据库设计反模式"></a>mysql反模式（3）– 第二部分 物理数据库设计反模式</h1><p>在这一部分中，提出了更加高效的数据管理的方式，包括如何选取合适的数据类型、如何存储大文件、以及如何规划索引的使用等等。</p>
<p>主要章节如下：</p>
<ol>
<li><p>第10章 取整错误 – 如何正确的选取数据类型</p>
</li>
<li><p>第11章 每日新花样 – 数据库中得枚举类型介绍</p>
</li>
<li><p>第12章 幽灵文件 – 图片或多媒体文件如果不谨慎的选取存储方案，就会变成幽灵文件</p>
</li>
<li><p>第13章 乱用索引 – 充分的利用索引，让数据库再为你多做一点点</p>
</li>
</ol>
<h2 id="第10章-取整错误"><a href="#第10章-取整错误" class="headerlink" title="第10章 取整错误"></a>第10章 取整错误</h2><p>从学习编程开始，浮点数相关的错误就层出不穷。10*0.1到底等于多少这个问题在不同的编程语言、情景之下可能结果都会有不同，数据库中，浮点数存储也是一个要尤其注意的问题。</p>
<p>在各类报表尤其是财务报表中，浮点数的计算非常常见。本章的目标就是使用小数取代证书，存储非整数类型的数字，并且在基本运算中使用他们。</p>
<p>一个显而易见的反模式就是：使用FLOAT类型。</p>
<p>但是由于并不是所有十进制中描述的信息都能使用二进制存储，所以浮点数通常都会被舍入。这种舍入是必要了，但是问题在于，十进制所输入的有限精度的小数，在作为二进制存储中却并不能以相同的精度存储。按照IEEE 794的规定，十进制数59.95会被表示为59.950000762939. 在很多计算场景下，这不是问题，但是一旦牵扯到是否相等的比较，问题就来了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE Accounts (</div><div class="line">     hourly_rate FLOAT</div><div class="line">);</div><div class="line"></div><div class="line">INSERT INTO Accounts (hourly_rate) VALUES (59.95);</div><div class="line">SELECT * FROM Accounts WHERE hourly_rate=59.95;</div></pre></td></tr></table></figure>
<p>返回的结果为空。一种可能的解决方案是通过差值小于某值取近似相等，但是需要找到合适的阀值才行。 </p>
<p>同样，在使用合计函数SUM计算很多值时，误差也不可避免。</p>
<p>因此，任何使用FLOAT、REAL或者DOUBLE PRECISION类型的设计都可能是反模式，大部分应用程序中得浮点数取值范围并不需要达到IEEE 754标准所定义的最大区间。</p>
<p>应用FLOAT的合适场景应该是，当需要存储的数据的取值范围很大，大于INTERGER 和NUMERIC两个类型所支持的范围时。如科学计算。</p>
<p><strong>解决方案：使用NUMERIC类型。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ALTER TABLE Accounts ADD COLUMN hourly_rate NUMERIC(9,2);</div></pre></td></tr></table></figure>
<p>指定精度，包括整数和小数位。这样可以避免FLOAT类型可能的摄入。除了NUMERIC还可以使用DECIMAL。这两个类型的行为是一样的。 </p>
<h2 id="第11章-每日新花样"><a href="#第11章-每日新花样" class="headerlink" title="第11章 每日新花样"></a>第11章 每日新花样</h2><p>在个人信息表中，称呼列可以只有一个有限的候选值：Mr. Mrs. Ms Dr. Rev. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE PersonalContacts (</div><div class="line">    ….</div><div class="line">    salutation VARCHAR(4)</div><div class="line">        CHECK (salutation IN (‘Mr.’,’Mrs.’,’Ms.’,’Dr.’,’Rev.&apos;))</div><div class="line">);</div></pre></td></tr></table></figure>
<p>类似于枚举类型，本以为这已经够了，结果发现法国人称呼不同，要加Mile。。。</p>
<p>本章的目标是限定列的有效值:将一列的有效字段值约束在一个固定集合中，从而拒绝无效值输入。</p>
<p>很多人趋向于在数据库设计进行列定义时指定可选值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE Bugs</div><div class="line">   --- other culumn ---</div><div class="line">  status VARCHAR(20) CHECK (status IN (&apos;NEW&apos;,&apos;IN PROGRESS&apos;,&apos;FIXED&apos;)</div><div class="line">);</div></pre></td></tr></table></figure>
<p>mysql同时支持enum类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE Bugs (</div><div class="line">    --- other columns ---</div><div class="line">    status ENUM(&apos;NEW&apos;,&apos;IN PROGRESS&apos;,&apos;FIXED&apos;)</div><div class="line">);</div></pre></td></tr></table></figure>
<p>这种解决方案可能带来三个问题：</p>
<ul>
<li>完成这样的定义之后，如果想从数据库获取所有的状态，变成了一件很困难的事。可行的方法是从系统视图中取，但是非常复杂。 </li>
<li>如果想添加新的状态，必须修改数据库定义，这种队员数据的修改应该非常注意质量。</li>
<li>如果想删掉以前的状态，原有带有这个状态的数据会变得非常棘手。<br>主要的问题就在于候选值结合并不固定，如果候选值几乎不变，那么ENUM或者CHECK就是一个好的选择。这时候就可以在程序中维护一份拷贝，从而方便读取。</li>
</ul>
<p>解决方案就是：</p>
<ul>
<li>创建一张检查表，每一行包含一个允许在状态列中出现的候选值，然后定义一个外键约束</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">CREATE TABL BugStatus (</div><div class="line">     status VARCHAR(20) PRIMARY KEY</div><div class="line">);</div><div class="line"></div><div class="line">INSERT INTO BugStatus (status) VALUES (’NEW’),(‘IN PROGRESS’),(‘FIXED’);</div><div class="line"></div><div class="line">CREATE TABLE Bugs (</div><div class="line">    ….</div><div class="line">    status VARCHAR(20),</div><div class="line">    FOREIGN KEY (status) REFERENCES BugStatus(status)</div><div class="line">        ON UPDATE CASCADE //会联动</div><div class="line">);</div></pre></td></tr></table></figure>
<p>这种设计使得查询集合非常方便：直接SELECTBugStatus中所有行。更新、插入和删除原有状态也是如此。与此同时，这种解决方案的兼容性也非常好，不会与不同的数据库产生过多的耦合。</p>
<h2 id="第12章-幽灵文件"><a href="#第12章-幽灵文件" class="headerlink" title="第12章 幽灵文件"></a>第12章 幽灵文件</h2><p> 本章的目标是存储图片或其他多媒体大文件。</p>
<p>一种常见的做法是使用文件系统，数据表中存储图片的路径，然后将实际的文件存在硬盘里。还有一种做法是利用blob类型将文件以二进制形式存储。那么，孰优孰劣呢？</p>
<ul>
<li>文件不支持DELETE: 数据库的删除操作跟真正文件的删除根本就不相干</li>
<li>文件不支持事务隔离：一旦删除了文件，其他客户端立刻就无法访问了</li>
<li>文件不支持回滚：删除了就真的没了</li>
<li>文件不支持数据库备份工具：外部数据无法备份</li>
<li>文件不支持SQL的访问权限设置：GRANT和REVOKE 语句设定的访问权限无法支持</li>
<li><p>文件不是SQL数据类型：数据库对文件的位置、名字等约束并不存在。<br>在考虑下面几个问题之后，再重新来看文件的问题：</p>
</li>
<li><p>数据备份和恢复的过程是怎样的？怎么对备份验证？</p>
</li>
<li>图片文件堆积在哪里，还是当孤立时就从系统移除？</li>
<li>系统中哪些用户有权限查看图片？进入权限如何限制？当用户请求他们无权查看的图片时会发生什么？</li>
<li><p>能撤销对图片的变更吗？如果能，是应用程序来负责恢复图片之前的状态吗？<br>那么，哪些场景下可以把图片存储在外面？</p>
</li>
<li><p>数据库在没有图片时能精益很多，图片太大了</p>
</li>
<li>当不包含图片时备份更快</li>
<li>如果存储在数据库之外，对图片的预览或者编辑能使用更简单直接的处理方式</li>
<li>如果这些将图片存储在文件系统中得好处是重要的，并且之前几节所描述的那些事项并不会破坏你的系统，那就可以肯定将图片存储在数据库之外是个好选择。</li>
</ul>
<p>但是如果想要避免上文中提到的，存储在文件系统的坏处，那么就需要使用BLOB类型进行存储：</p>
<ul>
<li>图片数据存储在数据库中，不需要额外的步骤加载它，也就没有“文件路径不正确”这样的风险</li>
<li>删除一条记录的同时也自动删除了图片</li>
<li>知道你提交了事务，否则对图片的改变是对其他客户端不可见的</li>
<li>更新记录时会加锁，回滚事务当然也能恢复图片之前的状态</li>
<li>数据库备份不会漏掉图片</li>
<li>SQL权限控制对图片也有效</li>
</ul>
<p>MySQL可以通过LOAD_FILE()函数载入文件，也可以用DUMPFILE的方式直接写入文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">UPDATE  screenshot_image </div><div class="line">SET screenshot_image = LOAD_FILE(‘image/screenshot1234-1.jpg’)</div><div class="line">WHERE bug_id = 1234 AND image_id = 1;</div><div class="line"></div><div class="line">SELECT screenshot_image</div><div class="line">INTO DUMPFILE ‘images/screenshot1234-1.jpg’</div><div class="line">FROM Screenshots</div><div class="line">WHERE bug_id = 1234 AND image_id=1;</div></pre></td></tr></table></figure>
<p>##第13章 乱用索引<br>本周的目标是尽可能的优化数据库的性能，当然，在不乱用索引的前提之下。</p>
<p>改善性能最好的技术就是在数据库中合理的使用索引。索引作为一种数据结构，能使数据库将指定列中某个值快速定位在相应的行。索引提供了一种简单而高效的途径能够让数据库快速找到需要的值，而不是全局遍历。</p>
<p>反模式就是蛮横的使用索引，而不管它究竟适合于什么场景。使用索引时，会有三种常见的错误：</p>
<p>不使用索引或索引不足<br>必须意识到，正确的索引能够通过带给你更好的好处来抵消它的额外开销。它最好的好处就是避免全表遍历<br>使用了太多的索引或者使用了一些无效索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE Bugs (</div><div class="line">    bug_id SERIAL PRIMARY KEY,</div><div class="line">    date_reported DATE NOT NULL,</div><div class="line">    summary VARCHAR(80) NOT NULL,</div><div class="line">    status     VARCHAR(10) NOT NULL,</div><div class="line">    hours    NUMERIC(9,2),</div><div class="line">    INDEX (bug_id),</div><div class="line">    INDEX (summary),</div><div class="line">    INDEX (hours),</div><div class="line">    INDEX (bug_id, date_reported,status)</div><div class="line">);</div></pre></td></tr></table></figure>
<p>显然这里有很多无用的索引：</p>
<ul>
<li>bug_id:大多数数据库都为主键自动建立索引，额外定义索引就是冗余的操作</li>
<li>summary: 对于长字符串，比如VARCHAR(80) 这种类型的索引要比更为紧凑数据类型的索引大很多，而且又不可能全字匹配查找</li>
<li>hours: 很少可能会全匹配查找</li>
<li>bug,date_reported,status: 组合索引是好选择，但是大多数人创建的组合索引通常都是冗余索引或者很少使用，同时组合索引的顺序也很重要，查询时需要照着来。</li>
<li>执行一些让索引无能为力的查询</li>
<li>以电话薄为例，由于姓都是按照字母大小排列的，因此将姓作为索引查询效率会提升很大，但是如果以名作为索引，那几乎就相当于是要做全表的扫描。因为名的排列并不遵循任何的顺序。</li>
<li>上述规则在数据库中也是如此，除此之外，哪些LIKE进行匹配子串的操作也无法利用任何索引的好处。<br>因此，在选择数据库索引这个议题上必须加以斟酌。分离率是衡量数据库索引的一个指标，它是一张表中所有不重复值的数量和总记录的条数之比：</li>
</ul>
<p>SELECT COUNT(DISTINCT status) /<br>    COUNT(status) AS selectivity FROM Bugs;<br>分离率越低，索引效率就越低。相当于是很多重复的记录，必须不停查。</p>
<p>如果想要使用好索引，那么一定要注意下面几点：</p>
<ol>
<li>测量<br>当然测量之前，最好确定数据库就是平静。<br>Mysql中使用慢查询日志，一般配置文件中long_query_time设为10s，注意禁止缓存，从而获得真实的结果。<br>通过profile分许，可以进行更准确的查询时间信息的查看<br>一旦找到比较慢得查询，就可以着手进行针对性的优化了。</li>
<li>解释<br>找原因的时候到了，查询执行计划（QEP）登场<br>mysql中使用EXPLAIN来生产qep报告。报告中一般会指出查询使用的主键索引，以及是否引入临时表、是否存在索引优化等多种信息。<br>mysql文档“Optimizing  Queries with EXPLAIN”有更详细的信息</li>
<li>挑选<br>那些没有使用索引的查询操作必须被放在放大镜下好好看看。<br>有一个解决方案是索引覆盖：如果一个索引包含了所有需要的列，那就不需要再从表中获取数据了。</li>
<li>测试<br>必须跟踪才能确定优化是否有效</li>
<li>优化<br>可以使用增加索引缓存的方式进一步提高效率。同时索引预加载也是一个方法：LOAD INDEX INTO CACHE</li>
<li>重建<br>平衡的时候是索引最高效的时候。不断的更新和删除记录会使得索引不平衡，就像文件系统带来的磁盘碎片一样。因此定期的索引维护是必要的MYSQL中又ANALYZE或OPTIMIZE TABLE来重建索引。<br>重建的频率视情况而定，所有是否值得的判断都需要数据操作者来做。<br>关于优化索引，最重要的规则就是，千万别瞎猜索引的使用方法。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/11/23/mysql反模式2/" itemprop="url">
                  mysql反模式2
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-11-23T23:47:47+08:00" content="Nov 23 2014">
              Nov 23 2014
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/11/23/mysql反模式2/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/11/23/mysql反模式2/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#mysql反模式2</p>
<p>继续第一部分：逻辑型数据库设计反模式</p>
<p>##第四章：需要ID：<br>必须意识到主键的本质，并且正确的使用它。<br>很多时候，建立数据库表中的主键都是处于一种习惯，而不是对表本身的认知。一个常见的错误是，在存储关系的交叉表中，主键并不能标识唯一性，真正的唯一性是对表之间关系的描述。</p>
<p>这一章的目标是找出那些尽管使用了主键，但是却混淆了主键的本质的情况。</p>
<p><strong>主键是数据库确保数据行在整张表中唯一性的保障，它是定位到一条记录且确保不会重复存储的逻辑机制。</strong>如果你需要确保一张表中的数据不会出现重复行，并且需要在查询中引用单独的一行记录，还要支持外键，那么主键是必须的。</p>
<p>对于那些没有明确主键的表，往往会引入一个对表的模型无意义的新列作为伪主键。MYSQL中，伪主键具有AUTO_INCREMENT的特性。</p>
<p>反模式：</p>
<ul>
<li>主键的名字叫做id</li>
<li>数据类型是32位或64位整型</li>
<li>主键的值自动生成以保证唯一</li>
<li>这个反模式会有如下的问题：</li>
</ul>
<p><strong>冗余键值</strong>：很多时候有更好的、更自然、更符合表意义的主键，没有必要每张表都用id这个字段。<br><strong>允许重复项</strong>：正如开头所说的，对于描述关系的交叉表，单独的主键不足以标识唯一性。假设个人与银行帐号信息有一张关系表，那么唯一的应该是（个人id，帐号id）这一个组合，而非单独主键。可以用UNIQUE KEY(个人id，帐号id)来标识之，这时候就不需要id这个单独的主键了。<br><strong>意义不明的关键字</strong>：主键的名称应该尽可能的有意义，id所拥有的信息太少了。</p>
<p>联结查询时有一个更简洁的方式，比如<figure class="highlight plain"><figcaption><span>* FROM Bugs AS b JOIN BugsProducts AS bp ON (b.bug_id = bp.bug_id)```等同于 ```SELECT * FROM Bugs JOIN BugsProducts USING (bug_id);``` 如果一定要定义伪主键为id，那么就无法利用这个特性。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">尽管如此，如果遇到一些假设“惯例优于配置”的面向对象框架，那么可能不得不使用id作为主键了。同时对于太长而不方便实现的自然键来说，伪主键是很好的代替品。</div><div class="line"></div><div class="line">因此对主键应该进行裁剪设计：</div><div class="line"></div><div class="line">* 直截了当：为主键选择更有意义的名称；同时外键应该尽可能的和所引用的列使用相同的名称，从而使他们在整个数据库的设计中唯一；</div><div class="line">* 拥抱自然键和组合键：如果表中已经包含了一列能够确保唯一、非空以及能够用来定位一条记录的字段，那么就不必要加伪主键了。不过由于数据库的设计趋向于在整个项目的生命周期中不断的调整优化，在没有合适的列的时候，伪主键就成了唯一的选择。合适的时候使用组合键，真正对数据的唯一性进行约束。</div><div class="line">在探讨主键的这一章需要注意，规范仅仅在它有帮助时才是好的。</div><div class="line"></div><div class="line">## 第五章：不用钥匙的入口：</div><div class="line">究竟应不应该使用外键约束保证引用完整性，还是代码来保证？</div><div class="line">外键在工作中常常是让我疑惑的一个部分，到底是否应该使用外键，它带来的好处和坏处究竟如何？一直没有一个非常清楚的认识，这章仔仔细细的剖析了一下其中的利弊。为了避免后续让人非常头疼的脚本式运维，还是适当的加上外键为好。</div><div class="line"></div><div class="line">**这一章的目标是简化数据库架构：关系型数据库的设计基本上可以说就是关于每张独立表之间的关系的设计。引用完整性当然是合理的数据库设计和操作非常重要的部分。**</div><div class="line"></div><div class="line">有些人不推荐使用外键，理由如下：</div><div class="line"></div><div class="line">* 数据更新可能和约束冲突</div><div class="line">* 数据库设计很灵活，不支持引用完整性约束</div><div class="line">* 数据库为外键建立的索引会影响性能</div><div class="line">* 数据库不支持外键</div><div class="line">* 定义外键语法复杂</div><div class="line">但是如果不定义外键，真的那么美好么？：</div><div class="line"></div><div class="line">使用代码来维护引用完整性，或许你对自己的代码有足够的自信，但是半年前的呢？别人的呢？同时需要在代码层面维护并发读写的问题，脏数据看起来简直无法避免。</div><div class="line">发现脏数据时，大多数的选择是定期脚本检查错误，简单逻辑或许可以删除相应记录，但是负责逻辑会使脚本异常复杂。</div><div class="line">对于这种不负责任的情况，必须加以声明约束。</div><div class="line"></div><div class="line">对于那些在数据库的层面上可以完美解决的问题，没有必要使用复杂的代码逻辑来完成。因为数据库的解决方案非常优雅，查查手册，定义一下外键，这会给程序带来巨大收益。</div><div class="line"></div><div class="line">同时外键也可以通过引入 级联更新的方式，在外键约束中声明 ON UPDATE或ON DELETE能够控制级联操作的结果。比如ON UPDATE CASCADE表明更新时一起更新，ON DELETE SET DEFAULT表示删除时设为默认值。</div><div class="line"></div><div class="line">不可避免的是外键带来的系统开销，但是相比于更新删除记录前select检查、同步修改时锁表、执行监控脚本来修正孤立数据，这些开销真心不算大。</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">## 第六章：实体-属性-值：</div><div class="line">面向对象的编程语言能够通过派生基类的方式进行属性扩展，那么如果数据库表出现类似的情况该如何处理呢？</div><div class="line">可扩展性是很多软件项目设计中得普遍目标。一般的数据设计中，一张表有一些属性，每条记录都表示相似的对象实例。不同的表就是不同的对象。</div><div class="line"></div><div class="line">但是现代面向对象的编程模型中，不同对象类型可能是相连的、可能是派生的等各种关系。在这种场景下，我们想要公用，想要将这种面向对象的关系体现在数据库的设计中。</div><div class="line"></div><div class="line">因此引出了如下的数据库设计：实体-属性-值（EAV）。</div><div class="line"></div><div class="line">**实体**：通常是一个指向父表的外键</div><div class="line">**属性**：每一列的名字</div><div class="line">示例如下：</div></pre></td></tr></table></figure></p>
<p>CREATE TABLE Issues (<br>    issue_id SERIAL PRIMARY KEY<br>);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line">CREATE TABLE IssueAttributes (</div><div class="line">     issue_id           BIGINT UNSIGNED NOT NULL,</div><div class="line">     attr_name        VARCHAR(100) NOT NULL,</div><div class="line">     attr_value        VARCHAR(100),</div><div class="line">     PRIMARY KEY (issue_id, attar_name),</div><div class="line">     FOREIGN KEY (issue_id) REFERENCES Issues (issue_id)</div><div class="line">);</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">INSERT INTO IssueAttributes (issue_id,attr_name,attr_value)</div><div class="line">    VALUES</div><div class="line">        (1234,&apos;product&apos;,&apos;1&apos;),</div><div class="line">        (1234,&apos;reported&apos;,&apos;tom&apos;),</div><div class="line">        (1234,&apos;status&apos;,&apos;NEW&apos;),</div></pre></td></tr></table></figure>
<p>尽管看上去设计不错，但是问题多多：</p>
<ul>
<li>不好查询</li>
<li>数据完整性、声明属性的SQL数据类型、非空限制、引用完整性这些数据库 的特性统统享受不到了。 </li>
<li>事实上关系型数据库并不支持这种程度的灵活性，这种EAV的设计号称能任意扩展，但是显然没用对地方。</li>
</ul>
<p>对于非关系数据管理的需求，最好求助于非关系技术：</p>
<p>Berkeley DB<br>Cassandra：分布式面向咧的数据库，facebook开发，提交给了apache<br>CouchDB：面向文档的数据库，分布式的key-value系统，使用json编码数据<br>Hadoop+Hbase、MongoDB、Redis等等<br>回到开头面向对象的数据库设计，有如下的几种解决方案：</p>
<ul>
<li>单表继承：将所有的属性都存在一张表里，然后通过type进行区分。比如客户和送货员公用性别属性，但是详细信息就有所不同了。这种方案问题在于加入新类型要改的地方比较多，同时比较难记录哪个属性属于哪个类型。但是当子类型少、特殊属性也少的时候，这是个不错的选择。</li>
<li>实体表继承：为每个子类型创建独立表，表既包含共有属性也包含特殊属性。好处是一行记录里不需要存跟自己无关的属性了，坏处是通用属性和特殊属性不好区分，同时不好查询所有的子类型。</li>
<li>类表继承：模拟继承，创建基类表、衍生表，使用外键相连。这是不错的选择。</li>
<li>半结构化数据类型：如果子类型很多或者必须经常增加新属性，那就blob列存储数据，用XML或json格式。直接丢进数据库，这个方案绝对灵活可扩展。但问题是sql基本没办法获取某个指定属性。</li>
</ul>
<h2 id="第七章：多态关联："><a href="#第七章：多态关联：" class="headerlink" title="第七章：多态关联："></a>第七章：多态关联：</h2><p>A表中的记录可能匹配B表或C表的记录，使用type来区分是一个好的选择么？<br>显然用type不是一个好的选择，本章的内容，在第二章乱穿马路已经有所涉及。多态关联指的是子表引用多个父表的情况。比如评论可能来自留言板或博客区，使用type区分会带来查询的复杂和数据的混乱。和第二章一样，交叉表是最好的解决方案。这里不展开了。</p>
<h2 id="第八章：多列属性："><a href="#第八章：多列属性：" class="headerlink" title="第八章：多列属性："></a>第八章：多列属性：</h2><p>与第二章比较类似，当一个属性有多个值时，如何处理？<br>本章则完全是对第二章的拓展，只不过使用了更明显的一个例子，给客户打标签。这种多对多的关系，天生就应该交给交叉表去处理。</p>
<h2 id="第九章：元数据分裂："><a href="#第九章：元数据分裂：" class="headerlink" title="第九章：元数据分裂："></a>第九章：元数据分裂：</h2><p>当一张表的数据量太大以至于影响性能的时候，手动分隔是愚蠢的，有很多分区或标准化的方式可以解决这个问题。<br>随着时间的推移，数据库中得数据肯定也是逐渐积累。那么数据库的查询性能肯定也随之下降了。这时候，即使索引也都无济于事了。因此本章的目标是优化数据库的结构来提升查询的性能以及支持表的平滑扩展。</p>
<p>一种非常错误的做法是，拆表存储或是拆列存储。这会造成：</p>
<ul>
<li>不断产生的新表：按照年份来分的话，每年都要加</li>
<li>管理数据完整性：万一按照年份写错了，查询结果会有问题</li>
<li>同步数据：更新日期需要异常谨慎，这竟会影响这条记录最终出现在哪个表中</li>
<li>确保唯一性：必须确保分割出来的表中的主键都唯一，冲突了就不好玩了。因此需要额外的id生成器。如下所示：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE BugsIdGenerator (bug_id SERIAL PRIMARY KEY);</div><div class="line"></div><div class="line">INSERT INTO BugsIdGenerator (bug_id) VALUES (DEFAULT);</div><div class="line">ROLLBACK;</div><div class="line"></div><div class="line">INSERT INTO Bugs_2010 (bug_id,…)</div><div class="line">     VALUES (LAST_INSERT_ID(),…);</div></pre></td></tr></table></figure>
<ul>
<li>跨表查询：想要跨年查询的时候，会很复杂。</li>
<li>管理引用完整性：掉进泥潭里了，拆分之后不再能使用外键</li>
<li>元数据分裂了：如果属性A按年份了，属性B呢，早晚的事。<br>只有一个场景下，上述方式是可取的，那就是归档数据时。</li>
</ul>
<p>所以正确的解决方案应该是，分区及标准化。</p>
<ol>
<li>使用水平分区：根据行对表进行拆分。只需要定义一些规则，来进行对逻辑表的拆分。这种单向的哈希函数，让你不用担心数据放错表，本例中被分成了四个部分，如果觉得不够，那在数据库设计时就应该选取更多的分区。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE Bugs (</div><div class="line">     bug_id SERIAL PRIMARY KEY,</div><div class="line">     ….</div><div class="line">     date_reported DATE</div><div class="line">) PARTITION BY HASH (YEAR(date_reported))</div><div class="line">     PARTITION 4;</div></pre></td></tr></table></figure>
<ol>
<li>使用垂直分区：根据列对表进行拆分。BLOB类型和TEXT类型的列的大小可变，为了提高查询和存储性能，一般数据库会自动将这些列和其他列分开存储。从而提高效率。如果使用*查询，一般会性能很差，因为这些大字段也被选择出来了。所以最好将这些大字段分开存储，在MySQL的MyISAM存储引擎中，对一个所有行的大小都是固定的表最高效。因此可以通过适当的拆分提高效率。</li>
</ol>
<p>第一部分：逻辑型数据库设计反模式到此结束，主要探讨了不同场景下，如何通过更贴近数据库特性的设计方式，来避免实际数据库使用中可能遇到的问题。一句话，数据库能做到的事，千万别自己做，数据库能做好的事，就用这种更优雅的方式。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/11/23/mysql反模式1/" itemprop="url">
                  mysql反模式1
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-11-23T20:23:12+08:00" content="Nov 23 2014">
              Nov 23 2014
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/11/23/mysql反模式1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/11/23/mysql反模式1/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="mysql反模式1"><a href="#mysql反模式1" class="headerlink" title="mysql反模式1"></a>mysql反模式1</h1><p>之前由于业务设计数据库的需要，网络搜索时搜到了mysql反模式这本书的章节片段，读来觉得非常有收获。因此特意买来深入读了一下，收获颇多，在此分享一下。</p>
<p>在这本书中，深入剖析了数据库编程中的常见错误，并且十分坦诚的指出，noSQL不是万能药，cache也不是，你应该首先对SQL有更加深入的认识。在我看来，它给人带来最大的启发有两点：第一点是它灵活的结合了很多应用场景，提出了非常实用且有效的解决方案，让你拿来即用，实在是比较惊喜。</p>
<p>第二点是它看似罗嗦繁复地指出了很多对数据库认识的常见谬误或是那些我们觉得众人皆知的注意点。但是要意识到，很多编程时的习惯或注意点在我们谈论的时候可能很清楚，但是真正到项目实践的时候却往往模棱两可。这是因为我们对这些注意点的理解并不透彻，只知道该这么做，但是不这么做了有什么不好，做了又有哪些好处，往往是说不太清楚。因此这种书很多时候厘清了这些灰色地带，明确且逻辑清晰的说明哪些数据库使用方法就是错误的。在熟知了来龙去脉之后，我们在编程时也自然会加倍小心，防止为后续运维带来大坑。</p>
<p>很多人对SQL的学习都是因为项目所需自学，而不是像其他编程语言那样从头开始。在写完了一些基本的SQL语句之后，一个很自然的问题就出现了：到底什么样的SQL语句才是高性能的？这本书尝试回答了一些这方面的问题，但是更多的还是需要我们自己去考虑和实践。</p>
<p>所谓反模式是指一种试图解决问题的方法，但是通常会同时引发别的问题。</p>
<p>此书在结构上分成四个部分，</p>
<p>第一部分是逻辑数据库设计反模式：这部分指出了在开始编码前，如何决定数据库里存储什么信息，以及最佳的数据组织方式和内在关联方式是什么。也就是如何设计数据库的表、字段和关系。</p>
<p>第二部分是物理数据库设计反模式，在知道了需要存储哪些数据后，就需要更高效的数据管理，包含了如何选择数据类型、定义表和索引。</p>
<p>第三部分是查询反模式，主要是说明获取数据时要注意的反模式。</p>
<p>第四部分是应用程序开发反模式，SQL肯定是与多种编程语言构建的应用程序结合然后加以用用。在应用程序中使用SQL的方式有好有坏，这部分内容描述了一些常见错误。</p>
<p>##第一部分：逻辑型数据库设计反模式</p>
<p>###第二章：乱穿马路：<br>很多时候程序员会使用逗号分隔的列表来避免在多对多的关系中创建交叉表，这是一种常见的反模式。</p>
<p>本章的目标是能够存储多值属性，假定有一张Products，产品表，其中对应多个联系人。同时每个联系人也会对应多个产品。这就构成了一种多对多的关系。</p>
<blockquote>
<p>反模式：格式化的逗号分割列表 contacts: ‘tom,lily,jack’</p>
</blockquote>
<p>通过逗号分隔将多个联系人信息写入产品表，这可能会在性能和数据完整性上都带来问题：</p>
<ul>
<li>查询指定账号的产品时：只能通过正则匹配的方式，无法享受索引的性能优势</li>
<li>查询指定产品的账号及相关信息时：在与账号表做连接查询时，逗号分隔的* 账号列表会带来很大的不便</li>
<li>聚合查询时：无法使用聚合函数，它们不适用于逗号分隔的列表</li>
<li>更新指定产品的账号时：账号列表无法保证顺序，更新账号列表被分裂成先选取后更新的两部操作。</li>
<li>验证输入合法性：字符串的存储弱化了类型校验，容易引入非法输入</li>
<li>选择合适的分隔符：使用何种分隔符也是问题</li>
<li>长度限制：总不能无限可控的扩展账号列表所属字段的长度吧？</li>
</ul>
<p>尽管有上述的诸多问题，但是逗号分隔的解决方案也可能在如下场景适用：</p>
<ul>
<li>应用程序需要逗号分隔这种存储格式</li>
<li>没有必要获取列表单独项</li>
<li>但是其他场景下，就需要寻求新的解决方案： 创建交叉表(一张表有指向另两张表的外键时)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE Contacts (</div><div class="line">    product_id BIGINT UNSIGNED NOT NULL,</div><div class="line">    account_id BIGINT UNSIGNED NOT NULL,</div><div class="line">    PRIMARY KEY (product_id , account_id),</div><div class="line">    FOREIGN KEY (product_id) REFERENCES Products(product_id),</div><div class="line">    FOREIGN KEY (account_id) REFERENCES Acounts(account_id)</div><div class="line">)</div></pre></td></tr></table></figure>
<p> 新的设计下，考虑之前的应用场景：</p>
<p>通过账号查询产品和反过来查询：简单地联结查询，更好的使用了索引<br>聚合查询：交叉表中描述了足够的关系，统计变得相对简单了。还可以进行复杂统计，比如查询相关账号最多的产品：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">SELECT c.product_id, c.accounts_per_product </div><div class="line">FROM (</div><div class="line">     SELECT product_id, COUNT(*) AS accounts_per_product</div><div class="line">     FROM contacts </div><div class="line">     GROUP BY product_id</div><div class="line">) AS c</div><div class="line">HAVING c.accounts_per_product = MAX(c.accounts_per_product)</div></pre></td></tr></table></figure>
<p>更新指定产品的相关联系人：一条语句，插入或删除即可</p>
<ul>
<li>验证产品ID：使用SQL数据类型和外键约束</li>
<li>选择分隔符：不需要分隔符了</li>
<li>列表长度：无限制</li>
<li>其他好处：许多数据库中，声明某一列为外键会隐式地为该列创建索引。也可以在交叉表中轻松加入更多的描述产品与联系人之间关系的字段。<br>一般情况下，每个值都应该存储在各自的行与列中。</li>
</ul>
<p>###第三章：单纯的树：<br>如何针对不同的应用场景设计出封层的存储与查询结构？对于树形结构的设计一旦需求考虑不清楚，就是牵一发动全身的事。</p>
<p>树形结构常见于各类组织架构、分层管理相关的模型设计中。本章的目标是高效的分层存储与查询。层级数据中，很可能需要查询与整个集合或其子集相关的特定对象，比如：</p>
<ul>
<li>组织架构图：职员与经理的关系</li>
<li>线程化讨论：标识回复评论的评论链</li>
<li>反模式：总是依赖父节点</li>
</ul>
<p>常见的解决方案是增加parent_id字段，来描述子节点与父节点之间的关系。这样的设计称为邻接表。这种方式有其便利和局限的地方，下述实例中便可看到：</p>
<p>使用邻接表查询树：非常明显的短板在于它无法查询一个节点的所有后代。parent_id只描述了两层的关系，但是树的特性就是它可以任意深的扩展。当你查询的时候，有多深，就要扩展多少个联结查询。这一方面很笨拙，另一方面数据库也不支持无限深度。另一种获取数据的方式是先查询所有行，然后在应用程序中拼树。这种大量的数据复制，效率同样也很低，同时增加了程序的复杂性。<br>使用邻接表维护树：有一些操作，邻接表是非常简单地：</p>
<ul>
<li>增加叶子结点</li>
<li>修改节点位置或子树的位置</li>
<li>但是删除比较复杂，尤其是删除子树的时候必须遍历所有后代节点。</li>
</ul>
<p>如果说快速的读取一个给定节点的直接父子节点，以及插入新节点是你程序对分层数据的全部操作，那么邻接表可以很好地工作。注意不要过度设计，而是考虑产品的实际需求，并不是每个地方都需要meta，都需要可扩展性。</p>
<p>总而言之，使用邻接表常常会出现多步数据库操作才能完成一次逻辑操作的情况，这样就会有很多额外的代码，而其实数据库设计本身就能做的简单高效。这也是大多数时候，追求优雅、高效的数据库设计的原因。</p>
<p>解决方案：使用其他树模型</p>
<p>包括 路径枚举、嵌套集和闭包表在内的三种模型，看上去比邻接表复杂很多，但是的确能够使得树的某些操作变得更简单。</p>
<h4 id="路径枚举"><a href="#路径枚举" class="headerlink" title="路径枚举"></a>路径枚举</h4><p>通过将所有祖先的信息联合成一个字符串存储，解决邻接表获取给定节点的所有祖先开销很大的问题。比如’1/4/6/7’ 就表示节点7到根节点之间的路径。</p>
<p>在查询节点的祖先时只需要：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SELECT *</div><div class="line">FROM Comments AS c</div><div class="line">WHERE ‘1/4/6/7’ LIKE c.path || ‘%’</div></pre></td></tr></table></figure>
<p>这会匹配到路径为’1/4/6/%’,’1/4/%’ 以及 ‘1/%’的节点，即为7的祖先。</p>
<p>查询给定节点的后代也是一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SELECT *</div><div class="line">FROM Comments AS c</div><div class="line">WHERE c.path LIKE ‘1/4/‘ || ‘%’</div></pre></td></tr></table></figure>
<p>即可匹配到’1/4/6’,’1/4/5’ 等后代节点。</p>
<p>在这两个查询的基础上，可以完成诸如计算一棵子树上节点的值得总和、子树上节点的数量这类计算。 </p>
<p>同样，插入节点也很简单，只需要复制其父节点的路径，并加上当前节点即可。可以使用LAST_INSERT_ID()函数获得刚刚插入的那条ID。</p>
<p>尽管路径枚举获取子树、层级和路径简单，但是路径枚举也存在其局限性：</p>
<p>数据库不能保证路径格式总正确或路径中节点确实存在<br>依赖于程序的逻辑代码维护路径的字符串，验证字符串正确的开销很大<br>无论将varchar设为多大，总不能支持其无限扩展。<br>还是那句话，按需选择。</p>
<h4 id="嵌套集"><a href="#嵌套集" class="headerlink" title="嵌套集"></a>嵌套集</h4><p>这种解决方案存储子孙节点的相关信息，而不是节点的直接祖先。nsleft和nsright</p>
<p>nsleft：小于该节点的所有后代的ID</p>
<p>nsright：大于该节点的所有后代ID</p>
<p>comment_id: 节点id</p>
<p>确定三者的简单方法是深度优先遍历进行分配。逐层深入是依次递增分配nsleft，返回时依次递增分配nsright。</p>
<p>分配完成后，就可以通过搜索那些节点的ID在节点4的nsleft和nsright的范围之间来获取这个节点及其所有后代：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">SELECT c2.*</div><div class="line">FROM Comments AS c1</div><div class="line">  JOIN Comments as c2</div><div class="line">    ON c2.nsleft BETWEEN c1.nsleft and c1.nsright</div><div class="line">WHERE c1.comment_id=4</div></pre></td></tr></table></figure>
<p> 反过来，通过搜索节点6在哪些节点的nsleft和nsright之间就可以找到节点6的所有祖先：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">SELECT c2.*</div><div class="line">FROM Comments AS c1</div><div class="line">  JOIN Comments AS c2</div><div class="line">    ON c1.nsleft BETWEEN c2.nsleft and c2.nsright</div><div class="line">WHERE c1.comment_id=6;</div></pre></td></tr></table></figure>
<p>使用嵌套集设计的主要优势是，当你想要删除一个非叶子结点时，它的后代会自动地代替被删除的节点，成为其直接祖先节点的直接后代。当删除一个节点造成数值不连续时，并不会对树的结构产生任何影响。</p>
<p>但是嵌套集的问题在于，对树进行操作，比如插入和移动节点会复杂很多。每次都要更新整棵树。</p>
<p>如果简单快速地查询是整个程序中最重要的部分，那么嵌套集是最佳选择  – 比操作单独节点要方便快捷。然后，嵌套集的插入和移动节点是比较复杂的，因为需要重新分配左右值。</p>
<h4 id="闭包表"><a href="#闭包表" class="headerlink" title="闭包表"></a>闭包表</h4><p> 简单而优雅的解决方案，记录了树中所有节点间的关系，而不仅仅只有那些直接的父子关系。</p>
<p>额外设计一张TreePath表，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE TreePaths (</div><div class="line">    ancestor BIGINT UNSIGNED NOT NULL,</div><div class="line">    descendant BIGINT UNSIGNED NOT NULL,</div><div class="line">    PRIMARY KEY (ancestor,descendant),</div><div class="line">    FOREIGN KEY (ancestor) REFERENCES Comments(comment_id),</div><div class="line">    FOREIGN KEY (descendant) REFERENCES Comments(comment_id)</div><div class="line">);</div></pre></td></tr></table></figure>
<p>将所有祖先后代关系，都描述在此表中，同时增加一行指向自己。</p>
<p>通过这张表获取祖先和后代比使用嵌套集更加直接。比如评论4的后代，只需要搜索祖先是评论4的即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">SELECT c.*</div><div class="line">FROM Comments AS c</div><div class="line">    JOIN TreePaths AS t ON c.comment_id=t.descendant</div><div class="line">WHERE t.ancestor = 4;</div></pre></td></tr></table></figure>
<p>获取祖先也是一样。</p>
<p>而插入新叶子节点，比如节点5的后代，则需要首先插入一条自己到自己的关系，然后搜索TreePath中后代是节点5的节点，再增加关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">INSERT INTO TreePaths (ancestor, descendant)</div><div class="line">    SELECT t.ancestor,8</div><div class="line">    FROM TreePaths AS t</div><div class="line">    WHERE t.descendant = 5</div><div class="line">  UNION ALL </div><div class="line">    SELECT 8,8</div></pre></td></tr></table></figure>
<p>要删除叶子节点以及删除完整子树也是遵循同样地原则。必须清除所有的关系。</p>
<p>要从一个地方移动一棵子树到另一个地方，需要分成几步：</p>
<p>首先断开这棵子树及其祖先的关系：找到这棵子树的顶点，删除它所有子节点和它所有祖先节点的关系，以将节点6从节点4下移动到节点3为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">DELETE FROM TreePaths </div><div class="line">WHERE descendant IN (SELECT descendant        </div><div class="line">         FROM TreePaths </div><div class="line">         WHERE ancestor = 6) </div><div class="line">    AND ancestor IN (SELECT ancestor </div><div class="line">         FROM TreePaths </div><div class="line">         WHERE descendant = 6 </div><div class="line">             AND ancestor != descendant);</div></pre></td></tr></table></figure>
<p>查询节点6的祖先（不包括自身的关系），以及节点6的后代，然后断开其关系。</p>
<p>然后将这颗孤立的树及它的祖先建立关系，可以使用CROSS JOIN语句来创建一个新节点及其祖先和这课孤立的树中所有节点的笛卡尔积来建立所有需要的关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">INSERT INTO TreePaths (ancestor descendant)</div><div class="line">     SELECT supertree.ancestor, subtree.descendant</div><div class="line">     FROM TreePaths AS super tree</div><div class="line">          CROSS JOIN TreePaths AS subtree</div><div class="line">     WHERE super tree.descendant = 3</div><div class="line">         AND subtree.ancestor = 6;</div></pre></td></tr></table></figure>
<p>闭包表的设计比嵌套集更加直接，两者都能快捷地查询给定节点的祖先和后代，但是闭包表能更加简单地维护分层信息。这两个设计都比使用邻接表或者路径枚举更方便的查询给定节点的直接后代和父代。</p>
<p>同时，可以通过添加path_length字段来优化闭包表，从而能够更加方便的查询直接父亲节点或子节点：哪些长度为1的，肯定是直接的父子节点。</p>
<table>
<thead>
<tr>
<th style="text-align:left">设计</th>
<th style="text-align:right">表</th>
<th style="text-align:center">查询子</th>
<th style="text-align:right">查询树</th>
<th style="text-align:right">插入</th>
<th style="text-align:left">删除</th>
<th style="text-align:left">引用完整性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">邻接表</td>
<td style="text-align:right">1</td>
<td style="text-align:center">简单</td>
<td style="text-align:right">困难</td>
<td style="text-align:right">简单</td>
<td style="text-align:left">简单</td>
<td style="text-align:left">是</td>
</tr>
<tr>
<td style="text-align:left">递归查询</td>
<td style="text-align:right">1</td>
<td style="text-align:center">简单</td>
<td style="text-align:right">简单</td>
<td style="text-align:right">简单</td>
<td style="text-align:left">简单</td>
<td style="text-align:left">是</td>
</tr>
<tr>
<td style="text-align:left">枚举路径</td>
<td style="text-align:right">1</td>
<td style="text-align:center">简单</td>
<td style="text-align:right">简单</td>
<td style="text-align:right">简单</td>
<td style="text-align:left">简单</td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">嵌套集</td>
<td style="text-align:right">1</td>
<td style="text-align:center">困难</td>
<td style="text-align:right">简单</td>
<td style="text-align:right">困难</td>
<td style="text-align:left">困难</td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">闭包集</td>
<td style="text-align:right">2</td>
<td style="text-align:center">简单</td>
<td style="text-align:right">简单</td>
<td style="text-align:right">简单</td>
<td style="text-align:left">简单</td>
<td style="text-align:left">是</td>
</tr>
</tbody>
</table>
<p> 邻接表是最方便的设计，很多开发者都了解</p>
<ul>
<li>如果数据库支持WITH或CONECT BY PRIOR的递归查询，那么邻接表查询能更高效</li>
<li>枚举路径能很直观地展示祖先到后代直接的路径，但是不能确保引用完整性，比较脆弱，数据也比较冗余。</li>
<li>嵌套很聪明，但是太聪明了，只适用于查询性能要求很高的场合。</li>
<li>闭包表最通用，也允许一个节点属于多棵树，使用空间换了时间。<br>一个分层数据结构包含了数据项和它们之间的关系，需要合理的设计两者的模型来配合自己的工作。</li>
</ul>
<p>下一节将继续介绍逻辑数据库反模式的其他内容。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/11/23/崇明团建随感/" itemprop="url">
                  崇明团建随感
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-11-23T20:18:30+08:00" content="Nov 23 2014">
              Nov 23 2014
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/生活随感/" itemprop="url" rel="index">
                    <span itemprop="name">生活随感</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/11/23/崇明团建随感/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/11/23/崇明团建随感/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="崇明团建"><a href="#崇明团建" class="headerlink" title="崇明团建"></a>崇明团建</h1><p>最近项目与部门颇多团建的机会，趁着秋高气爽的时日，不出去走一走岂不是辜负了一片美景。</p>
<p>来上海也是将近10年了，但是对崇明岛却从未踏足。这一次有机会自驾穿过上海长江大桥和长兴岛，一路到达崇明岛。令人十分欣喜。在桥前高速路上，视野所见只是桥、天和大江。不禁让人心怀开阔，仅仅是为了这景色，也已经算是不虚此行了。</p>
<p>崇明岛状狭长，乃是长江长期冲积所形成的三角洲，据说现在正在建造海底隧道直通地铁，松软的砂质估计要为建造带来不少难度了。车过大桥，一路向西，走出城市的拘束，秋色在路边映入眼帘。风柔、天青、云静，树影婆娑。尤其是那乡间小道，如卫兵般站立的白杨英姿飒爽，绿中透红的枫叶随风摆动，想想也是醉了。</p>
<p>一路驱车到底此行的目的地，前卫村。不大的院子，一排三层小楼整整齐齐，一看就是统一规划设计的。每家每户差别不大，选哪个都是土菜、烧烤、农家乐。颇具规模。泊好车进门一看，三国杀已经热火朝天了。趁着饭时未到，几个人围坐一桌，也玩起了狼人。<br><img src="http://meijing0114.qiniudn.com/meijing01144.pic_hd.jpg?imageView2/2/q/85" alt="前卫村"></p>
<p>晚餐不出所料，一顿农家大餐。还有专注崇明的alex同学边吃边解说，从崇明神奇的黄金瓜，到鲜嫩诱人的崇明蟹，还有不得不提的崇明红烧羊肉。一道道都是色香味俱全，再加上饭店老板在旁极力推销，这一餐倒是吃的颇有兴致。<br><img src="http://meijing0114.qiniudn.com/meijing01142.pic_hd.jpg?imageView2/2/q/85" alt="崇明蟹"></p>
<p>团建时大家无拘无束，平日不太了解的一些同事，也逐渐熟悉起来。工作关系，说到底还是人与人之间的关系。很多时候，如果跟你这个人都不是很熟的话，很难去进行合作，也很容易在合作的时候发生抵触。所以团建的意义，确实拉近了大家的关系。</p>
<p>饭后又是一番你死我活的狼人搏杀之后，终于迎来了重头戏，烧烤！</p>
<p>很多时候，一次活动可能就那么几个场景让你历历在目。因为人的记忆容量有限，过一段时候就会清理一下存储。而那些给你带来最深刻印象的事物，自然会记得最清楚。狼人杀杀了啥基本上忘的差不多了，但是崇明夜雾之下，门口路灯的微光，吹风机当鼓风机用得幽默，烘的脸庞通红的炭火，下肚却仍驱不去的严寒的米酒，烤肉大厨娴熟翻烤上油的双手，吃下一推半生半焦食物之后围作一圈的畅聊。这些场景历历在目，可能就是隔着一层夜雾，模糊而又清晰，轻松却带着深刻，让人觉得格外的美好。值得记在心里，写在文中，让自己不忘。</p>
<p>终于，大家累了，倦了，去崇明大坝探险的几位哥也回来了。能熬的还在麻将桌前拼杀，不能熬的就早早睡下，与室友叙叙，等待着朝阳的到来。<br><img src="http://meijing0114.qiniudn.com/meijing01149.pic.jpg?imageView2/2/q/85" alt="早"><br>来自miss owl</p>
<p>一大早群里就很热闹，看来暖暖的太阳比被窝还有吸引力。早餐过后就是小镇的走马观花，顺带还在院里pk了一下篮球。<br>以下是miss owl同学所拍摄的照片，超赞！<br><img src="http://meijing0114.qiniudn.com/meijing01146.pic.jpg?imageView2/2/q/85" alt="村景1"><br><img src="http://meijing0114.qiniudn.com/meijing01147.pic.jpg?imageView2/2/q/85" alt="村景2"><br><img src="http://meijing0114.qiniudn.com/meijing01148.pic.jpg?imageView2/2/q/85" alt="村景3"></p>
<p>大家明显都还带有晚睡的疲惫，中午一顿大餐过后，就要正式踏上归程了。回去的路上，云层丰富多彩，天空大开大合，城市与之相比不可同日而语。真想去美国50号公路自驾一下，体验一下人、车、路的那种融合！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/11/19/frontpage/" itemprop="url">
                  meijing0114的博客
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-11-19T22:29:47+08:00" content="Nov 19 2014">
              Nov 19 2014
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/生活随感/" itemprop="url" rel="index">
                    <span itemprop="name">生活随感</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/11/19/frontpage/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/11/19/frontpage/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>欢迎来到meijing0114的技术博客，这里会有个人技术成长过程中的各类漫谈。包括但不限于<strong>web后台技术</strong>、<strong>ios技术</strong>，以及<strong>服务器运维</strong>相关技术。</p>
<blockquote>
<p>穿越长城，走向世界</p>
<p>Accross the Great Wall we can reach every corner in the world.</p>
<p>Ueber die Grosse Mauer koennen wir alle Erke des Welt ereichen.</p>
</blockquote>
<h2 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h2><hr>
<p><em>php</em> <code>echo &quot;hello world!&quot;;</code></p>
<p><em>c++</em> <code>std::cout&lt;&lt;&quot;hello world!&quot;;</code></p>
<p><em>c</em> <code>printf(&quot;hello world!&quot;);</code></p>
<p><em>python</em> <code>print &quot;hello world!&quot;</code></p>
<hr>
<h2 id="web技术"><a href="#web技术" class="headerlink" title="web技术"></a>web技术</h2><ul>
<li><strong>数据层</strong>：<ul>
<li>mysql：高性能mysql</li>
<li>redis：</li>
<li>no-sql</li>
</ul>
</li>
<li><strong>逻辑层</strong>：<ul>
<li>MVC模型</li>
</ul>
</li>
<li><strong>接入层</strong>：<ul>
<li>nginx: 深入理解nginx</li>
<li>apache：</li>
<li>cache： memcache</li>
</ul>
</li>
<li><strong>web前端</strong><ul>
<li>js、jquery</li>
<li>css</li>
<li>html</li>
</ul>
</li>
<li><strong>运维相关</strong><ul>
<li>bash</li>
<li>shell</li>
</ul>
</li>
</ul>
<hr>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.jpg"
               alt="meijing0114" />
          <p class="site-author-name" itemprop="name">meijing0114</p>
          <p class="site-description motion-element" itemprop="description">记录科技与生活</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">39</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">meijing0114</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"meijing0114"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>
