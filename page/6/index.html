<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="meijing0114的博客" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="记录科技与生活">
<meta property="og:type" content="website">
<meta property="og:title" content="meijing0114的博客">
<meta property="og:url" content="http://meijing0114.me/page/6/index.html">
<meta property="og:site_name" content="meijing0114的博客">
<meta property="og:description" content="记录科技与生活">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="meijing0114的博客">
<meta name="twitter:description" content="记录科技与生活">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"always"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://meijing0114.me/page/6/"/>

  <title> meijing0114的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?a5a4534386a17bda81a3d4f5669e4b7b";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">meijing0114的博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/11/23/mysql反模式-3-第二部分物理数据库设计反模式/" itemprop="url">
                  mysql反模式(3)--第二部分物理数据库设计反模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-11-23T23:58:27+08:00" content="Nov 23 2014">
              Nov 23 2014
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/11/23/mysql反模式-3-第二部分物理数据库设计反模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/11/23/mysql反模式-3-第二部分物理数据库设计反模式/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="mysql反模式（3）–-第二部分-物理数据库设计反模式"><a href="#mysql反模式（3）–-第二部分-物理数据库设计反模式" class="headerlink" title="mysql反模式（3）– 第二部分 物理数据库设计反模式"></a>mysql反模式（3）– 第二部分 物理数据库设计反模式</h1><p>在这一部分中，提出了更加高效的数据管理的方式，包括如何选取合适的数据类型、如何存储大文件、以及如何规划索引的使用等等。</p>
<p>主要章节如下：</p>
<ol>
<li><p>第10章 取整错误 – 如何正确的选取数据类型</p>
</li>
<li><p>第11章 每日新花样 – 数据库中得枚举类型介绍</p>
</li>
<li><p>第12章 幽灵文件 – 图片或多媒体文件如果不谨慎的选取存储方案，就会变成幽灵文件</p>
</li>
<li><p>第13章 乱用索引 – 充分的利用索引，让数据库再为你多做一点点</p>
</li>
</ol>
<h2 id="第10章-取整错误"><a href="#第10章-取整错误" class="headerlink" title="第10章 取整错误"></a>第10章 取整错误</h2><p>从学习编程开始，浮点数相关的错误就层出不穷。10*0.1到底等于多少这个问题在不同的编程语言、情景之下可能结果都会有不同，数据库中，浮点数存储也是一个要尤其注意的问题。</p>
<p>在各类报表尤其是财务报表中，浮点数的计算非常常见。本章的目标就是使用小数取代证书，存储非整数类型的数字，并且在基本运算中使用他们。</p>
<p>一个显而易见的反模式就是：使用FLOAT类型。</p>
<p>但是由于并不是所有十进制中描述的信息都能使用二进制存储，所以浮点数通常都会被舍入。这种舍入是必要了，但是问题在于，十进制所输入的有限精度的小数，在作为二进制存储中却并不能以相同的精度存储。按照IEEE 794的规定，十进制数59.95会被表示为59.950000762939. 在很多计算场景下，这不是问题，但是一旦牵扯到是否相等的比较，问题就来了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE Accounts (</div><div class="line">     hourly_rate FLOAT</div><div class="line">);</div><div class="line"></div><div class="line">INSERT INTO Accounts (hourly_rate) VALUES (59.95);</div><div class="line">SELECT * FROM Accounts WHERE hourly_rate=59.95;</div></pre></td></tr></table></figure>
<p>返回的结果为空。一种可能的解决方案是通过差值小于某值取近似相等，但是需要找到合适的阀值才行。 </p>
<p>同样，在使用合计函数SUM计算很多值时，误差也不可避免。</p>
<p>因此，任何使用FLOAT、REAL或者DOUBLE PRECISION类型的设计都可能是反模式，大部分应用程序中得浮点数取值范围并不需要达到IEEE 754标准所定义的最大区间。</p>
<p>应用FLOAT的合适场景应该是，当需要存储的数据的取值范围很大，大于INTERGER 和NUMERIC两个类型所支持的范围时。如科学计算。</p>
<p><strong>解决方案：使用NUMERIC类型。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ALTER TABLE Accounts ADD COLUMN hourly_rate NUMERIC(9,2);</div></pre></td></tr></table></figure>
<p>指定精度，包括整数和小数位。这样可以避免FLOAT类型可能的摄入。除了NUMERIC还可以使用DECIMAL。这两个类型的行为是一样的。 </p>
<h2 id="第11章-每日新花样"><a href="#第11章-每日新花样" class="headerlink" title="第11章 每日新花样"></a>第11章 每日新花样</h2><p>在个人信息表中，称呼列可以只有一个有限的候选值：Mr. Mrs. Ms Dr. Rev. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE PersonalContacts (</div><div class="line">    ….</div><div class="line">    salutation VARCHAR(4)</div><div class="line">        CHECK (salutation IN (‘Mr.’,’Mrs.’,’Ms.’,’Dr.’,’Rev.&apos;))</div><div class="line">);</div></pre></td></tr></table></figure>
<p>类似于枚举类型，本以为这已经够了，结果发现法国人称呼不同，要加Mile。。。</p>
<p>本章的目标是限定列的有效值:将一列的有效字段值约束在一个固定集合中，从而拒绝无效值输入。</p>
<p>很多人趋向于在数据库设计进行列定义时指定可选值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE Bugs</div><div class="line">   --- other culumn ---</div><div class="line">  status VARCHAR(20) CHECK (status IN (&apos;NEW&apos;,&apos;IN PROGRESS&apos;,&apos;FIXED&apos;)</div><div class="line">);</div></pre></td></tr></table></figure>
<p>mysql同时支持enum类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE Bugs (</div><div class="line">    --- other columns ---</div><div class="line">    status ENUM(&apos;NEW&apos;,&apos;IN PROGRESS&apos;,&apos;FIXED&apos;)</div><div class="line">);</div></pre></td></tr></table></figure>
<p>这种解决方案可能带来三个问题：</p>
<ul>
<li>完成这样的定义之后，如果想从数据库获取所有的状态，变成了一件很困难的事。可行的方法是从系统视图中取，但是非常复杂。 </li>
<li>如果想添加新的状态，必须修改数据库定义，这种队员数据的修改应该非常注意质量。</li>
<li>如果想删掉以前的状态，原有带有这个状态的数据会变得非常棘手。<br>主要的问题就在于候选值结合并不固定，如果候选值几乎不变，那么ENUM或者CHECK就是一个好的选择。这时候就可以在程序中维护一份拷贝，从而方便读取。</li>
</ul>
<p>解决方案就是：</p>
<ul>
<li>创建一张检查表，每一行包含一个允许在状态列中出现的候选值，然后定义一个外键约束</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">CREATE TABL BugStatus (</div><div class="line">     status VARCHAR(20) PRIMARY KEY</div><div class="line">);</div><div class="line"></div><div class="line">INSERT INTO BugStatus (status) VALUES (’NEW’),(‘IN PROGRESS’),(‘FIXED’);</div><div class="line"></div><div class="line">CREATE TABLE Bugs (</div><div class="line">    ….</div><div class="line">    status VARCHAR(20),</div><div class="line">    FOREIGN KEY (status) REFERENCES BugStatus(status)</div><div class="line">        ON UPDATE CASCADE //会联动</div><div class="line">);</div></pre></td></tr></table></figure>
<p>这种设计使得查询集合非常方便：直接SELECTBugStatus中所有行。更新、插入和删除原有状态也是如此。与此同时，这种解决方案的兼容性也非常好，不会与不同的数据库产生过多的耦合。</p>
<h2 id="第12章-幽灵文件"><a href="#第12章-幽灵文件" class="headerlink" title="第12章 幽灵文件"></a>第12章 幽灵文件</h2><p> 本章的目标是存储图片或其他多媒体大文件。</p>
<p>一种常见的做法是使用文件系统，数据表中存储图片的路径，然后将实际的文件存在硬盘里。还有一种做法是利用blob类型将文件以二进制形式存储。那么，孰优孰劣呢？</p>
<ul>
<li>文件不支持DELETE: 数据库的删除操作跟真正文件的删除根本就不相干</li>
<li>文件不支持事务隔离：一旦删除了文件，其他客户端立刻就无法访问了</li>
<li>文件不支持回滚：删除了就真的没了</li>
<li>文件不支持数据库备份工具：外部数据无法备份</li>
<li>文件不支持SQL的访问权限设置：GRANT和REVOKE 语句设定的访问权限无法支持</li>
<li><p>文件不是SQL数据类型：数据库对文件的位置、名字等约束并不存在。<br>在考虑下面几个问题之后，再重新来看文件的问题：</p>
</li>
<li><p>数据备份和恢复的过程是怎样的？怎么对备份验证？</p>
</li>
<li>图片文件堆积在哪里，还是当孤立时就从系统移除？</li>
<li>系统中哪些用户有权限查看图片？进入权限如何限制？当用户请求他们无权查看的图片时会发生什么？</li>
<li><p>能撤销对图片的变更吗？如果能，是应用程序来负责恢复图片之前的状态吗？<br>那么，哪些场景下可以把图片存储在外面？</p>
</li>
<li><p>数据库在没有图片时能精益很多，图片太大了</p>
</li>
<li>当不包含图片时备份更快</li>
<li>如果存储在数据库之外，对图片的预览或者编辑能使用更简单直接的处理方式</li>
<li>如果这些将图片存储在文件系统中得好处是重要的，并且之前几节所描述的那些事项并不会破坏你的系统，那就可以肯定将图片存储在数据库之外是个好选择。</li>
</ul>
<p>但是如果想要避免上文中提到的，存储在文件系统的坏处，那么就需要使用BLOB类型进行存储：</p>
<ul>
<li>图片数据存储在数据库中，不需要额外的步骤加载它，也就没有“文件路径不正确”这样的风险</li>
<li>删除一条记录的同时也自动删除了图片</li>
<li>知道你提交了事务，否则对图片的改变是对其他客户端不可见的</li>
<li>更新记录时会加锁，回滚事务当然也能恢复图片之前的状态</li>
<li>数据库备份不会漏掉图片</li>
<li>SQL权限控制对图片也有效</li>
</ul>
<p>MySQL可以通过LOAD_FILE()函数载入文件，也可以用DUMPFILE的方式直接写入文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">UPDATE  screenshot_image </div><div class="line">SET screenshot_image = LOAD_FILE(‘image/screenshot1234-1.jpg’)</div><div class="line">WHERE bug_id = 1234 AND image_id = 1;</div><div class="line"></div><div class="line">SELECT screenshot_image</div><div class="line">INTO DUMPFILE ‘images/screenshot1234-1.jpg’</div><div class="line">FROM Screenshots</div><div class="line">WHERE bug_id = 1234 AND image_id=1;</div></pre></td></tr></table></figure>
<p>##第13章 乱用索引<br>本周的目标是尽可能的优化数据库的性能，当然，在不乱用索引的前提之下。</p>
<p>改善性能最好的技术就是在数据库中合理的使用索引。索引作为一种数据结构，能使数据库将指定列中某个值快速定位在相应的行。索引提供了一种简单而高效的途径能够让数据库快速找到需要的值，而不是全局遍历。</p>
<p>反模式就是蛮横的使用索引，而不管它究竟适合于什么场景。使用索引时，会有三种常见的错误：</p>
<p>不使用索引或索引不足<br>必须意识到，正确的索引能够通过带给你更好的好处来抵消它的额外开销。它最好的好处就是避免全表遍历<br>使用了太多的索引或者使用了一些无效索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE Bugs (</div><div class="line">    bug_id SERIAL PRIMARY KEY,</div><div class="line">    date_reported DATE NOT NULL,</div><div class="line">    summary VARCHAR(80) NOT NULL,</div><div class="line">    status     VARCHAR(10) NOT NULL,</div><div class="line">    hours    NUMERIC(9,2),</div><div class="line">    INDEX (bug_id),</div><div class="line">    INDEX (summary),</div><div class="line">    INDEX (hours),</div><div class="line">    INDEX (bug_id, date_reported,status)</div><div class="line">);</div></pre></td></tr></table></figure>
<p>显然这里有很多无用的索引：</p>
<ul>
<li>bug_id:大多数数据库都为主键自动建立索引，额外定义索引就是冗余的操作</li>
<li>summary: 对于长字符串，比如VARCHAR(80) 这种类型的索引要比更为紧凑数据类型的索引大很多，而且又不可能全字匹配查找</li>
<li>hours: 很少可能会全匹配查找</li>
<li>bug,date_reported,status: 组合索引是好选择，但是大多数人创建的组合索引通常都是冗余索引或者很少使用，同时组合索引的顺序也很重要，查询时需要照着来。</li>
<li>执行一些让索引无能为力的查询</li>
<li>以电话薄为例，由于姓都是按照字母大小排列的，因此将姓作为索引查询效率会提升很大，但是如果以名作为索引，那几乎就相当于是要做全表的扫描。因为名的排列并不遵循任何的顺序。</li>
<li>上述规则在数据库中也是如此，除此之外，哪些LIKE进行匹配子串的操作也无法利用任何索引的好处。<br>因此，在选择数据库索引这个议题上必须加以斟酌。分离率是衡量数据库索引的一个指标，它是一张表中所有不重复值的数量和总记录的条数之比：</li>
</ul>
<p>SELECT COUNT(DISTINCT status) /<br>    COUNT(status) AS selectivity FROM Bugs;<br>分离率越低，索引效率就越低。相当于是很多重复的记录，必须不停查。</p>
<p>如果想要使用好索引，那么一定要注意下面几点：</p>
<ol>
<li>测量<br>当然测量之前，最好确定数据库就是平静。<br>Mysql中使用慢查询日志，一般配置文件中long_query_time设为10s，注意禁止缓存，从而获得真实的结果。<br>通过profile分许，可以进行更准确的查询时间信息的查看<br>一旦找到比较慢得查询，就可以着手进行针对性的优化了。</li>
<li>解释<br>找原因的时候到了，查询执行计划（QEP）登场<br>mysql中使用EXPLAIN来生产qep报告。报告中一般会指出查询使用的主键索引，以及是否引入临时表、是否存在索引优化等多种信息。<br>mysql文档“Optimizing  Queries with EXPLAIN”有更详细的信息</li>
<li>挑选<br>那些没有使用索引的查询操作必须被放在放大镜下好好看看。<br>有一个解决方案是索引覆盖：如果一个索引包含了所有需要的列，那就不需要再从表中获取数据了。</li>
<li>测试<br>必须跟踪才能确定优化是否有效</li>
<li>优化<br>可以使用增加索引缓存的方式进一步提高效率。同时索引预加载也是一个方法：LOAD INDEX INTO CACHE</li>
<li>重建<br>平衡的时候是索引最高效的时候。不断的更新和删除记录会使得索引不平衡，就像文件系统带来的磁盘碎片一样。因此定期的索引维护是必要的MYSQL中又ANALYZE或OPTIMIZE TABLE来重建索引。<br>重建的频率视情况而定，所有是否值得的判断都需要数据操作者来做。<br>关于优化索引，最重要的规则就是，千万别瞎猜索引的使用方法。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/11/23/mysql反模式2/" itemprop="url">
                  mysql反模式2
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-11-23T23:47:47+08:00" content="Nov 23 2014">
              Nov 23 2014
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/11/23/mysql反模式2/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/11/23/mysql反模式2/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#mysql反模式2</p>
<p>继续第一部分：逻辑型数据库设计反模式</p>
<p>##第四章：需要ID：<br>必须意识到主键的本质，并且正确的使用它。<br>很多时候，建立数据库表中的主键都是处于一种习惯，而不是对表本身的认知。一个常见的错误是，在存储关系的交叉表中，主键并不能标识唯一性，真正的唯一性是对表之间关系的描述。</p>
<p>这一章的目标是找出那些尽管使用了主键，但是却混淆了主键的本质的情况。</p>
<p><strong>主键是数据库确保数据行在整张表中唯一性的保障，它是定位到一条记录且确保不会重复存储的逻辑机制。</strong>如果你需要确保一张表中的数据不会出现重复行，并且需要在查询中引用单独的一行记录，还要支持外键，那么主键是必须的。</p>
<p>对于那些没有明确主键的表，往往会引入一个对表的模型无意义的新列作为伪主键。MYSQL中，伪主键具有AUTO_INCREMENT的特性。</p>
<p>反模式：</p>
<ul>
<li>主键的名字叫做id</li>
<li>数据类型是32位或64位整型</li>
<li>主键的值自动生成以保证唯一</li>
<li>这个反模式会有如下的问题：</li>
</ul>
<p><strong>冗余键值</strong>：很多时候有更好的、更自然、更符合表意义的主键，没有必要每张表都用id这个字段。<br><strong>允许重复项</strong>：正如开头所说的，对于描述关系的交叉表，单独的主键不足以标识唯一性。假设个人与银行帐号信息有一张关系表，那么唯一的应该是（个人id，帐号id）这一个组合，而非单独主键。可以用UNIQUE KEY(个人id，帐号id)来标识之，这时候就不需要id这个单独的主键了。<br><strong>意义不明的关键字</strong>：主键的名称应该尽可能的有意义，id所拥有的信息太少了。</p>
<p>联结查询时有一个更简洁的方式，比如<figure class="highlight plain"><figcaption><span>* FROM Bugs AS b JOIN BugsProducts AS bp ON (b.bug_id = bp.bug_id)```等同于 ```SELECT * FROM Bugs JOIN BugsProducts USING (bug_id);``` 如果一定要定义伪主键为id，那么就无法利用这个特性。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">尽管如此，如果遇到一些假设“惯例优于配置”的面向对象框架，那么可能不得不使用id作为主键了。同时对于太长而不方便实现的自然键来说，伪主键是很好的代替品。</div><div class="line"></div><div class="line">因此对主键应该进行裁剪设计：</div><div class="line"></div><div class="line">* 直截了当：为主键选择更有意义的名称；同时外键应该尽可能的和所引用的列使用相同的名称，从而使他们在整个数据库的设计中唯一；</div><div class="line">* 拥抱自然键和组合键：如果表中已经包含了一列能够确保唯一、非空以及能够用来定位一条记录的字段，那么就不必要加伪主键了。不过由于数据库的设计趋向于在整个项目的生命周期中不断的调整优化，在没有合适的列的时候，伪主键就成了唯一的选择。合适的时候使用组合键，真正对数据的唯一性进行约束。</div><div class="line">在探讨主键的这一章需要注意，规范仅仅在它有帮助时才是好的。</div><div class="line"></div><div class="line">## 第五章：不用钥匙的入口：</div><div class="line">究竟应不应该使用外键约束保证引用完整性，还是代码来保证？</div><div class="line">外键在工作中常常是让我疑惑的一个部分，到底是否应该使用外键，它带来的好处和坏处究竟如何？一直没有一个非常清楚的认识，这章仔仔细细的剖析了一下其中的利弊。为了避免后续让人非常头疼的脚本式运维，还是适当的加上外键为好。</div><div class="line"></div><div class="line">**这一章的目标是简化数据库架构：关系型数据库的设计基本上可以说就是关于每张独立表之间的关系的设计。引用完整性当然是合理的数据库设计和操作非常重要的部分。**</div><div class="line"></div><div class="line">有些人不推荐使用外键，理由如下：</div><div class="line"></div><div class="line">* 数据更新可能和约束冲突</div><div class="line">* 数据库设计很灵活，不支持引用完整性约束</div><div class="line">* 数据库为外键建立的索引会影响性能</div><div class="line">* 数据库不支持外键</div><div class="line">* 定义外键语法复杂</div><div class="line">但是如果不定义外键，真的那么美好么？：</div><div class="line"></div><div class="line">使用代码来维护引用完整性，或许你对自己的代码有足够的自信，但是半年前的呢？别人的呢？同时需要在代码层面维护并发读写的问题，脏数据看起来简直无法避免。</div><div class="line">发现脏数据时，大多数的选择是定期脚本检查错误，简单逻辑或许可以删除相应记录，但是负责逻辑会使脚本异常复杂。</div><div class="line">对于这种不负责任的情况，必须加以声明约束。</div><div class="line"></div><div class="line">对于那些在数据库的层面上可以完美解决的问题，没有必要使用复杂的代码逻辑来完成。因为数据库的解决方案非常优雅，查查手册，定义一下外键，这会给程序带来巨大收益。</div><div class="line"></div><div class="line">同时外键也可以通过引入 级联更新的方式，在外键约束中声明 ON UPDATE或ON DELETE能够控制级联操作的结果。比如ON UPDATE CASCADE表明更新时一起更新，ON DELETE SET DEFAULT表示删除时设为默认值。</div><div class="line"></div><div class="line">不可避免的是外键带来的系统开销，但是相比于更新删除记录前select检查、同步修改时锁表、执行监控脚本来修正孤立数据，这些开销真心不算大。</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">## 第六章：实体-属性-值：</div><div class="line">面向对象的编程语言能够通过派生基类的方式进行属性扩展，那么如果数据库表出现类似的情况该如何处理呢？</div><div class="line">可扩展性是很多软件项目设计中得普遍目标。一般的数据设计中，一张表有一些属性，每条记录都表示相似的对象实例。不同的表就是不同的对象。</div><div class="line"></div><div class="line">但是现代面向对象的编程模型中，不同对象类型可能是相连的、可能是派生的等各种关系。在这种场景下，我们想要公用，想要将这种面向对象的关系体现在数据库的设计中。</div><div class="line"></div><div class="line">因此引出了如下的数据库设计：实体-属性-值（EAV）。</div><div class="line"></div><div class="line">**实体**：通常是一个指向父表的外键</div><div class="line">**属性**：每一列的名字</div><div class="line">示例如下：</div></pre></td></tr></table></figure></p>
<p>CREATE TABLE Issues (<br>    issue_id SERIAL PRIMARY KEY<br>);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line">CREATE TABLE IssueAttributes (</div><div class="line">     issue_id           BIGINT UNSIGNED NOT NULL,</div><div class="line">     attr_name        VARCHAR(100) NOT NULL,</div><div class="line">     attr_value        VARCHAR(100),</div><div class="line">     PRIMARY KEY (issue_id, attar_name),</div><div class="line">     FOREIGN KEY (issue_id) REFERENCES Issues (issue_id)</div><div class="line">);</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">INSERT INTO IssueAttributes (issue_id,attr_name,attr_value)</div><div class="line">    VALUES</div><div class="line">        (1234,&apos;product&apos;,&apos;1&apos;),</div><div class="line">        (1234,&apos;reported&apos;,&apos;tom&apos;),</div><div class="line">        (1234,&apos;status&apos;,&apos;NEW&apos;),</div></pre></td></tr></table></figure>
<p>尽管看上去设计不错，但是问题多多：</p>
<ul>
<li>不好查询</li>
<li>数据完整性、声明属性的SQL数据类型、非空限制、引用完整性这些数据库 的特性统统享受不到了。 </li>
<li>事实上关系型数据库并不支持这种程度的灵活性，这种EAV的设计号称能任意扩展，但是显然没用对地方。</li>
</ul>
<p>对于非关系数据管理的需求，最好求助于非关系技术：</p>
<p>Berkeley DB<br>Cassandra：分布式面向咧的数据库，facebook开发，提交给了apache<br>CouchDB：面向文档的数据库，分布式的key-value系统，使用json编码数据<br>Hadoop+Hbase、MongoDB、Redis等等<br>回到开头面向对象的数据库设计，有如下的几种解决方案：</p>
<ul>
<li>单表继承：将所有的属性都存在一张表里，然后通过type进行区分。比如客户和送货员公用性别属性，但是详细信息就有所不同了。这种方案问题在于加入新类型要改的地方比较多，同时比较难记录哪个属性属于哪个类型。但是当子类型少、特殊属性也少的时候，这是个不错的选择。</li>
<li>实体表继承：为每个子类型创建独立表，表既包含共有属性也包含特殊属性。好处是一行记录里不需要存跟自己无关的属性了，坏处是通用属性和特殊属性不好区分，同时不好查询所有的子类型。</li>
<li>类表继承：模拟继承，创建基类表、衍生表，使用外键相连。这是不错的选择。</li>
<li>半结构化数据类型：如果子类型很多或者必须经常增加新属性，那就blob列存储数据，用XML或json格式。直接丢进数据库，这个方案绝对灵活可扩展。但问题是sql基本没办法获取某个指定属性。</li>
</ul>
<h2 id="第七章：多态关联："><a href="#第七章：多态关联：" class="headerlink" title="第七章：多态关联："></a>第七章：多态关联：</h2><p>A表中的记录可能匹配B表或C表的记录，使用type来区分是一个好的选择么？<br>显然用type不是一个好的选择，本章的内容，在第二章乱穿马路已经有所涉及。多态关联指的是子表引用多个父表的情况。比如评论可能来自留言板或博客区，使用type区分会带来查询的复杂和数据的混乱。和第二章一样，交叉表是最好的解决方案。这里不展开了。</p>
<h2 id="第八章：多列属性："><a href="#第八章：多列属性：" class="headerlink" title="第八章：多列属性："></a>第八章：多列属性：</h2><p>与第二章比较类似，当一个属性有多个值时，如何处理？<br>本章则完全是对第二章的拓展，只不过使用了更明显的一个例子，给客户打标签。这种多对多的关系，天生就应该交给交叉表去处理。</p>
<h2 id="第九章：元数据分裂："><a href="#第九章：元数据分裂：" class="headerlink" title="第九章：元数据分裂："></a>第九章：元数据分裂：</h2><p>当一张表的数据量太大以至于影响性能的时候，手动分隔是愚蠢的，有很多分区或标准化的方式可以解决这个问题。<br>随着时间的推移，数据库中得数据肯定也是逐渐积累。那么数据库的查询性能肯定也随之下降了。这时候，即使索引也都无济于事了。因此本章的目标是优化数据库的结构来提升查询的性能以及支持表的平滑扩展。</p>
<p>一种非常错误的做法是，拆表存储或是拆列存储。这会造成：</p>
<ul>
<li>不断产生的新表：按照年份来分的话，每年都要加</li>
<li>管理数据完整性：万一按照年份写错了，查询结果会有问题</li>
<li>同步数据：更新日期需要异常谨慎，这竟会影响这条记录最终出现在哪个表中</li>
<li>确保唯一性：必须确保分割出来的表中的主键都唯一，冲突了就不好玩了。因此需要额外的id生成器。如下所示：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE BugsIdGenerator (bug_id SERIAL PRIMARY KEY);</div><div class="line"></div><div class="line">INSERT INTO BugsIdGenerator (bug_id) VALUES (DEFAULT);</div><div class="line">ROLLBACK;</div><div class="line"></div><div class="line">INSERT INTO Bugs_2010 (bug_id,…)</div><div class="line">     VALUES (LAST_INSERT_ID(),…);</div></pre></td></tr></table></figure>
<ul>
<li>跨表查询：想要跨年查询的时候，会很复杂。</li>
<li>管理引用完整性：掉进泥潭里了，拆分之后不再能使用外键</li>
<li>元数据分裂了：如果属性A按年份了，属性B呢，早晚的事。<br>只有一个场景下，上述方式是可取的，那就是归档数据时。</li>
</ul>
<p>所以正确的解决方案应该是，分区及标准化。</p>
<ol>
<li>使用水平分区：根据行对表进行拆分。只需要定义一些规则，来进行对逻辑表的拆分。这种单向的哈希函数，让你不用担心数据放错表，本例中被分成了四个部分，如果觉得不够，那在数据库设计时就应该选取更多的分区。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE Bugs (</div><div class="line">     bug_id SERIAL PRIMARY KEY,</div><div class="line">     ….</div><div class="line">     date_reported DATE</div><div class="line">) PARTITION BY HASH (YEAR(date_reported))</div><div class="line">     PARTITION 4;</div></pre></td></tr></table></figure>
<ol>
<li>使用垂直分区：根据列对表进行拆分。BLOB类型和TEXT类型的列的大小可变，为了提高查询和存储性能，一般数据库会自动将这些列和其他列分开存储。从而提高效率。如果使用*查询，一般会性能很差，因为这些大字段也被选择出来了。所以最好将这些大字段分开存储，在MySQL的MyISAM存储引擎中，对一个所有行的大小都是固定的表最高效。因此可以通过适当的拆分提高效率。</li>
</ol>
<p>第一部分：逻辑型数据库设计反模式到此结束，主要探讨了不同场景下，如何通过更贴近数据库特性的设计方式，来避免实际数据库使用中可能遇到的问题。一句话，数据库能做到的事，千万别自己做，数据库能做好的事，就用这种更优雅的方式。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/11/23/mysql反模式1/" itemprop="url">
                  mysql反模式1
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-11-23T20:23:12+08:00" content="Nov 23 2014">
              Nov 23 2014
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/11/23/mysql反模式1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/11/23/mysql反模式1/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="mysql反模式1"><a href="#mysql反模式1" class="headerlink" title="mysql反模式1"></a>mysql反模式1</h1><p>之前由于业务设计数据库的需要，网络搜索时搜到了mysql反模式这本书的章节片段，读来觉得非常有收获。因此特意买来深入读了一下，收获颇多，在此分享一下。</p>
<p>在这本书中，深入剖析了数据库编程中的常见错误，并且十分坦诚的指出，noSQL不是万能药，cache也不是，你应该首先对SQL有更加深入的认识。在我看来，它给人带来最大的启发有两点：第一点是它灵活的结合了很多应用场景，提出了非常实用且有效的解决方案，让你拿来即用，实在是比较惊喜。</p>
<p>第二点是它看似罗嗦繁复地指出了很多对数据库认识的常见谬误或是那些我们觉得众人皆知的注意点。但是要意识到，很多编程时的习惯或注意点在我们谈论的时候可能很清楚，但是真正到项目实践的时候却往往模棱两可。这是因为我们对这些注意点的理解并不透彻，只知道该这么做，但是不这么做了有什么不好，做了又有哪些好处，往往是说不太清楚。因此这种书很多时候厘清了这些灰色地带，明确且逻辑清晰的说明哪些数据库使用方法就是错误的。在熟知了来龙去脉之后，我们在编程时也自然会加倍小心，防止为后续运维带来大坑。</p>
<p>很多人对SQL的学习都是因为项目所需自学，而不是像其他编程语言那样从头开始。在写完了一些基本的SQL语句之后，一个很自然的问题就出现了：到底什么样的SQL语句才是高性能的？这本书尝试回答了一些这方面的问题，但是更多的还是需要我们自己去考虑和实践。</p>
<p>所谓反模式是指一种试图解决问题的方法，但是通常会同时引发别的问题。</p>
<p>此书在结构上分成四个部分，</p>
<p>第一部分是逻辑数据库设计反模式：这部分指出了在开始编码前，如何决定数据库里存储什么信息，以及最佳的数据组织方式和内在关联方式是什么。也就是如何设计数据库的表、字段和关系。</p>
<p>第二部分是物理数据库设计反模式，在知道了需要存储哪些数据后，就需要更高效的数据管理，包含了如何选择数据类型、定义表和索引。</p>
<p>第三部分是查询反模式，主要是说明获取数据时要注意的反模式。</p>
<p>第四部分是应用程序开发反模式，SQL肯定是与多种编程语言构建的应用程序结合然后加以用用。在应用程序中使用SQL的方式有好有坏，这部分内容描述了一些常见错误。</p>
<p>##第一部分：逻辑型数据库设计反模式</p>
<p>###第二章：乱穿马路：<br>很多时候程序员会使用逗号分隔的列表来避免在多对多的关系中创建交叉表，这是一种常见的反模式。</p>
<p>本章的目标是能够存储多值属性，假定有一张Products，产品表，其中对应多个联系人。同时每个联系人也会对应多个产品。这就构成了一种多对多的关系。</p>
<blockquote>
<p>反模式：格式化的逗号分割列表 contacts: ‘tom,lily,jack’</p>
</blockquote>
<p>通过逗号分隔将多个联系人信息写入产品表，这可能会在性能和数据完整性上都带来问题：</p>
<ul>
<li>查询指定账号的产品时：只能通过正则匹配的方式，无法享受索引的性能优势</li>
<li>查询指定产品的账号及相关信息时：在与账号表做连接查询时，逗号分隔的* 账号列表会带来很大的不便</li>
<li>聚合查询时：无法使用聚合函数，它们不适用于逗号分隔的列表</li>
<li>更新指定产品的账号时：账号列表无法保证顺序，更新账号列表被分裂成先选取后更新的两部操作。</li>
<li>验证输入合法性：字符串的存储弱化了类型校验，容易引入非法输入</li>
<li>选择合适的分隔符：使用何种分隔符也是问题</li>
<li>长度限制：总不能无限可控的扩展账号列表所属字段的长度吧？</li>
</ul>
<p>尽管有上述的诸多问题，但是逗号分隔的解决方案也可能在如下场景适用：</p>
<ul>
<li>应用程序需要逗号分隔这种存储格式</li>
<li>没有必要获取列表单独项</li>
<li>但是其他场景下，就需要寻求新的解决方案： 创建交叉表(一张表有指向另两张表的外键时)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE Contacts (</div><div class="line">    product_id BIGINT UNSIGNED NOT NULL,</div><div class="line">    account_id BIGINT UNSIGNED NOT NULL,</div><div class="line">    PRIMARY KEY (product_id , account_id),</div><div class="line">    FOREIGN KEY (product_id) REFERENCES Products(product_id),</div><div class="line">    FOREIGN KEY (account_id) REFERENCES Acounts(account_id)</div><div class="line">)</div></pre></td></tr></table></figure>
<p> 新的设计下，考虑之前的应用场景：</p>
<p>通过账号查询产品和反过来查询：简单地联结查询，更好的使用了索引<br>聚合查询：交叉表中描述了足够的关系，统计变得相对简单了。还可以进行复杂统计，比如查询相关账号最多的产品：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">SELECT c.product_id, c.accounts_per_product </div><div class="line">FROM (</div><div class="line">     SELECT product_id, COUNT(*) AS accounts_per_product</div><div class="line">     FROM contacts </div><div class="line">     GROUP BY product_id</div><div class="line">) AS c</div><div class="line">HAVING c.accounts_per_product = MAX(c.accounts_per_product)</div></pre></td></tr></table></figure>
<p>更新指定产品的相关联系人：一条语句，插入或删除即可</p>
<ul>
<li>验证产品ID：使用SQL数据类型和外键约束</li>
<li>选择分隔符：不需要分隔符了</li>
<li>列表长度：无限制</li>
<li>其他好处：许多数据库中，声明某一列为外键会隐式地为该列创建索引。也可以在交叉表中轻松加入更多的描述产品与联系人之间关系的字段。<br>一般情况下，每个值都应该存储在各自的行与列中。</li>
</ul>
<p>###第三章：单纯的树：<br>如何针对不同的应用场景设计出封层的存储与查询结构？对于树形结构的设计一旦需求考虑不清楚，就是牵一发动全身的事。</p>
<p>树形结构常见于各类组织架构、分层管理相关的模型设计中。本章的目标是高效的分层存储与查询。层级数据中，很可能需要查询与整个集合或其子集相关的特定对象，比如：</p>
<ul>
<li>组织架构图：职员与经理的关系</li>
<li>线程化讨论：标识回复评论的评论链</li>
<li>反模式：总是依赖父节点</li>
</ul>
<p>常见的解决方案是增加parent_id字段，来描述子节点与父节点之间的关系。这样的设计称为邻接表。这种方式有其便利和局限的地方，下述实例中便可看到：</p>
<p>使用邻接表查询树：非常明显的短板在于它无法查询一个节点的所有后代。parent_id只描述了两层的关系，但是树的特性就是它可以任意深的扩展。当你查询的时候，有多深，就要扩展多少个联结查询。这一方面很笨拙，另一方面数据库也不支持无限深度。另一种获取数据的方式是先查询所有行，然后在应用程序中拼树。这种大量的数据复制，效率同样也很低，同时增加了程序的复杂性。<br>使用邻接表维护树：有一些操作，邻接表是非常简单地：</p>
<ul>
<li>增加叶子结点</li>
<li>修改节点位置或子树的位置</li>
<li>但是删除比较复杂，尤其是删除子树的时候必须遍历所有后代节点。</li>
</ul>
<p>如果说快速的读取一个给定节点的直接父子节点，以及插入新节点是你程序对分层数据的全部操作，那么邻接表可以很好地工作。注意不要过度设计，而是考虑产品的实际需求，并不是每个地方都需要meta，都需要可扩展性。</p>
<p>总而言之，使用邻接表常常会出现多步数据库操作才能完成一次逻辑操作的情况，这样就会有很多额外的代码，而其实数据库设计本身就能做的简单高效。这也是大多数时候，追求优雅、高效的数据库设计的原因。</p>
<p>解决方案：使用其他树模型</p>
<p>包括 路径枚举、嵌套集和闭包表在内的三种模型，看上去比邻接表复杂很多，但是的确能够使得树的某些操作变得更简单。</p>
<h4 id="路径枚举"><a href="#路径枚举" class="headerlink" title="路径枚举"></a>路径枚举</h4><p>通过将所有祖先的信息联合成一个字符串存储，解决邻接表获取给定节点的所有祖先开销很大的问题。比如’1/4/6/7’ 就表示节点7到根节点之间的路径。</p>
<p>在查询节点的祖先时只需要：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SELECT *</div><div class="line">FROM Comments AS c</div><div class="line">WHERE ‘1/4/6/7’ LIKE c.path || ‘%’</div></pre></td></tr></table></figure>
<p>这会匹配到路径为’1/4/6/%’,’1/4/%’ 以及 ‘1/%’的节点，即为7的祖先。</p>
<p>查询给定节点的后代也是一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SELECT *</div><div class="line">FROM Comments AS c</div><div class="line">WHERE c.path LIKE ‘1/4/‘ || ‘%’</div></pre></td></tr></table></figure>
<p>即可匹配到’1/4/6’,’1/4/5’ 等后代节点。</p>
<p>在这两个查询的基础上，可以完成诸如计算一棵子树上节点的值得总和、子树上节点的数量这类计算。 </p>
<p>同样，插入节点也很简单，只需要复制其父节点的路径，并加上当前节点即可。可以使用LAST_INSERT_ID()函数获得刚刚插入的那条ID。</p>
<p>尽管路径枚举获取子树、层级和路径简单，但是路径枚举也存在其局限性：</p>
<p>数据库不能保证路径格式总正确或路径中节点确实存在<br>依赖于程序的逻辑代码维护路径的字符串，验证字符串正确的开销很大<br>无论将varchar设为多大，总不能支持其无限扩展。<br>还是那句话，按需选择。</p>
<h4 id="嵌套集"><a href="#嵌套集" class="headerlink" title="嵌套集"></a>嵌套集</h4><p>这种解决方案存储子孙节点的相关信息，而不是节点的直接祖先。nsleft和nsright</p>
<p>nsleft：小于该节点的所有后代的ID</p>
<p>nsright：大于该节点的所有后代ID</p>
<p>comment_id: 节点id</p>
<p>确定三者的简单方法是深度优先遍历进行分配。逐层深入是依次递增分配nsleft，返回时依次递增分配nsright。</p>
<p>分配完成后，就可以通过搜索那些节点的ID在节点4的nsleft和nsright的范围之间来获取这个节点及其所有后代：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">SELECT c2.*</div><div class="line">FROM Comments AS c1</div><div class="line">  JOIN Comments as c2</div><div class="line">    ON c2.nsleft BETWEEN c1.nsleft and c1.nsright</div><div class="line">WHERE c1.comment_id=4</div></pre></td></tr></table></figure>
<p> 反过来，通过搜索节点6在哪些节点的nsleft和nsright之间就可以找到节点6的所有祖先：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">SELECT c2.*</div><div class="line">FROM Comments AS c1</div><div class="line">  JOIN Comments AS c2</div><div class="line">    ON c1.nsleft BETWEEN c2.nsleft and c2.nsright</div><div class="line">WHERE c1.comment_id=6;</div></pre></td></tr></table></figure>
<p>使用嵌套集设计的主要优势是，当你想要删除一个非叶子结点时，它的后代会自动地代替被删除的节点，成为其直接祖先节点的直接后代。当删除一个节点造成数值不连续时，并不会对树的结构产生任何影响。</p>
<p>但是嵌套集的问题在于，对树进行操作，比如插入和移动节点会复杂很多。每次都要更新整棵树。</p>
<p>如果简单快速地查询是整个程序中最重要的部分，那么嵌套集是最佳选择  – 比操作单独节点要方便快捷。然后，嵌套集的插入和移动节点是比较复杂的，因为需要重新分配左右值。</p>
<h4 id="闭包表"><a href="#闭包表" class="headerlink" title="闭包表"></a>闭包表</h4><p> 简单而优雅的解决方案，记录了树中所有节点间的关系，而不仅仅只有那些直接的父子关系。</p>
<p>额外设计一张TreePath表，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE TreePaths (</div><div class="line">    ancestor BIGINT UNSIGNED NOT NULL,</div><div class="line">    descendant BIGINT UNSIGNED NOT NULL,</div><div class="line">    PRIMARY KEY (ancestor,descendant),</div><div class="line">    FOREIGN KEY (ancestor) REFERENCES Comments(comment_id),</div><div class="line">    FOREIGN KEY (descendant) REFERENCES Comments(comment_id)</div><div class="line">);</div></pre></td></tr></table></figure>
<p>将所有祖先后代关系，都描述在此表中，同时增加一行指向自己。</p>
<p>通过这张表获取祖先和后代比使用嵌套集更加直接。比如评论4的后代，只需要搜索祖先是评论4的即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">SELECT c.*</div><div class="line">FROM Comments AS c</div><div class="line">    JOIN TreePaths AS t ON c.comment_id=t.descendant</div><div class="line">WHERE t.ancestor = 4;</div></pre></td></tr></table></figure>
<p>获取祖先也是一样。</p>
<p>而插入新叶子节点，比如节点5的后代，则需要首先插入一条自己到自己的关系，然后搜索TreePath中后代是节点5的节点，再增加关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">INSERT INTO TreePaths (ancestor, descendant)</div><div class="line">    SELECT t.ancestor,8</div><div class="line">    FROM TreePaths AS t</div><div class="line">    WHERE t.descendant = 5</div><div class="line">  UNION ALL </div><div class="line">    SELECT 8,8</div></pre></td></tr></table></figure>
<p>要删除叶子节点以及删除完整子树也是遵循同样地原则。必须清除所有的关系。</p>
<p>要从一个地方移动一棵子树到另一个地方，需要分成几步：</p>
<p>首先断开这棵子树及其祖先的关系：找到这棵子树的顶点，删除它所有子节点和它所有祖先节点的关系，以将节点6从节点4下移动到节点3为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">DELETE FROM TreePaths </div><div class="line">WHERE descendant IN (SELECT descendant        </div><div class="line">         FROM TreePaths </div><div class="line">         WHERE ancestor = 6) </div><div class="line">    AND ancestor IN (SELECT ancestor </div><div class="line">         FROM TreePaths </div><div class="line">         WHERE descendant = 6 </div><div class="line">             AND ancestor != descendant);</div></pre></td></tr></table></figure>
<p>查询节点6的祖先（不包括自身的关系），以及节点6的后代，然后断开其关系。</p>
<p>然后将这颗孤立的树及它的祖先建立关系，可以使用CROSS JOIN语句来创建一个新节点及其祖先和这课孤立的树中所有节点的笛卡尔积来建立所有需要的关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">INSERT INTO TreePaths (ancestor descendant)</div><div class="line">     SELECT supertree.ancestor, subtree.descendant</div><div class="line">     FROM TreePaths AS super tree</div><div class="line">          CROSS JOIN TreePaths AS subtree</div><div class="line">     WHERE super tree.descendant = 3</div><div class="line">         AND subtree.ancestor = 6;</div></pre></td></tr></table></figure>
<p>闭包表的设计比嵌套集更加直接，两者都能快捷地查询给定节点的祖先和后代，但是闭包表能更加简单地维护分层信息。这两个设计都比使用邻接表或者路径枚举更方便的查询给定节点的直接后代和父代。</p>
<p>同时，可以通过添加path_length字段来优化闭包表，从而能够更加方便的查询直接父亲节点或子节点：哪些长度为1的，肯定是直接的父子节点。</p>
<table>
<thead>
<tr>
<th style="text-align:left">设计</th>
<th style="text-align:right">表</th>
<th style="text-align:center">查询子</th>
<th style="text-align:right">查询树</th>
<th style="text-align:right">插入</th>
<th style="text-align:left">删除</th>
<th style="text-align:left">引用完整性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">邻接表</td>
<td style="text-align:right">1</td>
<td style="text-align:center">简单</td>
<td style="text-align:right">困难</td>
<td style="text-align:right">简单</td>
<td style="text-align:left">简单</td>
<td style="text-align:left">是</td>
</tr>
<tr>
<td style="text-align:left">递归查询</td>
<td style="text-align:right">1</td>
<td style="text-align:center">简单</td>
<td style="text-align:right">简单</td>
<td style="text-align:right">简单</td>
<td style="text-align:left">简单</td>
<td style="text-align:left">是</td>
</tr>
<tr>
<td style="text-align:left">枚举路径</td>
<td style="text-align:right">1</td>
<td style="text-align:center">简单</td>
<td style="text-align:right">简单</td>
<td style="text-align:right">简单</td>
<td style="text-align:left">简单</td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">嵌套集</td>
<td style="text-align:right">1</td>
<td style="text-align:center">困难</td>
<td style="text-align:right">简单</td>
<td style="text-align:right">困难</td>
<td style="text-align:left">困难</td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">闭包集</td>
<td style="text-align:right">2</td>
<td style="text-align:center">简单</td>
<td style="text-align:right">简单</td>
<td style="text-align:right">简单</td>
<td style="text-align:left">简单</td>
<td style="text-align:left">是</td>
</tr>
</tbody>
</table>
<p> 邻接表是最方便的设计，很多开发者都了解</p>
<ul>
<li>如果数据库支持WITH或CONECT BY PRIOR的递归查询，那么邻接表查询能更高效</li>
<li>枚举路径能很直观地展示祖先到后代直接的路径，但是不能确保引用完整性，比较脆弱，数据也比较冗余。</li>
<li>嵌套很聪明，但是太聪明了，只适用于查询性能要求很高的场合。</li>
<li>闭包表最通用，也允许一个节点属于多棵树，使用空间换了时间。<br>一个分层数据结构包含了数据项和它们之间的关系，需要合理的设计两者的模型来配合自己的工作。</li>
</ul>
<p>下一节将继续介绍逻辑数据库反模式的其他内容。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/11/23/崇明团建随感/" itemprop="url">
                  崇明团建随感
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-11-23T20:18:30+08:00" content="Nov 23 2014">
              Nov 23 2014
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/生活随感/" itemprop="url" rel="index">
                    <span itemprop="name">生活随感</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/11/23/崇明团建随感/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/11/23/崇明团建随感/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="崇明团建"><a href="#崇明团建" class="headerlink" title="崇明团建"></a>崇明团建</h1><p>最近项目与部门颇多团建的机会，趁着秋高气爽的时日，不出去走一走岂不是辜负了一片美景。</p>
<p>来上海也是将近10年了，但是对崇明岛却从未踏足。这一次有机会自驾穿过上海长江大桥和长兴岛，一路到达崇明岛。令人十分欣喜。在桥前高速路上，视野所见只是桥、天和大江。不禁让人心怀开阔，仅仅是为了这景色，也已经算是不虚此行了。</p>
<p>崇明岛状狭长，乃是长江长期冲积所形成的三角洲，据说现在正在建造海底隧道直通地铁，松软的砂质估计要为建造带来不少难度了。车过大桥，一路向西，走出城市的拘束，秋色在路边映入眼帘。风柔、天青、云静，树影婆娑。尤其是那乡间小道，如卫兵般站立的白杨英姿飒爽，绿中透红的枫叶随风摆动，想想也是醉了。</p>
<p>一路驱车到底此行的目的地，前卫村。不大的院子，一排三层小楼整整齐齐，一看就是统一规划设计的。每家每户差别不大，选哪个都是土菜、烧烤、农家乐。颇具规模。泊好车进门一看，三国杀已经热火朝天了。趁着饭时未到，几个人围坐一桌，也玩起了狼人。<br><img src="http://meijing0114.qiniudn.com/meijing01144.pic_hd.jpg?imageView2/2/q/85" alt="前卫村"></p>
<p>晚餐不出所料，一顿农家大餐。还有专注崇明的alex同学边吃边解说，从崇明神奇的黄金瓜，到鲜嫩诱人的崇明蟹，还有不得不提的崇明红烧羊肉。一道道都是色香味俱全，再加上饭店老板在旁极力推销，这一餐倒是吃的颇有兴致。<br><img src="http://meijing0114.qiniudn.com/meijing01142.pic_hd.jpg?imageView2/2/q/85" alt="崇明蟹"></p>
<p>团建时大家无拘无束，平日不太了解的一些同事，也逐渐熟悉起来。工作关系，说到底还是人与人之间的关系。很多时候，如果跟你这个人都不是很熟的话，很难去进行合作，也很容易在合作的时候发生抵触。所以团建的意义，确实拉近了大家的关系。</p>
<p>饭后又是一番你死我活的狼人搏杀之后，终于迎来了重头戏，烧烤！</p>
<p>很多时候，一次活动可能就那么几个场景让你历历在目。因为人的记忆容量有限，过一段时候就会清理一下存储。而那些给你带来最深刻印象的事物，自然会记得最清楚。狼人杀杀了啥基本上忘的差不多了，但是崇明夜雾之下，门口路灯的微光，吹风机当鼓风机用得幽默，烘的脸庞通红的炭火，下肚却仍驱不去的严寒的米酒，烤肉大厨娴熟翻烤上油的双手，吃下一推半生半焦食物之后围作一圈的畅聊。这些场景历历在目，可能就是隔着一层夜雾，模糊而又清晰，轻松却带着深刻，让人觉得格外的美好。值得记在心里，写在文中，让自己不忘。</p>
<p>终于，大家累了，倦了，去崇明大坝探险的几位哥也回来了。能熬的还在麻将桌前拼杀，不能熬的就早早睡下，与室友叙叙，等待着朝阳的到来。<br><img src="http://meijing0114.qiniudn.com/meijing01149.pic.jpg?imageView2/2/q/85" alt="早"><br>来自miss owl</p>
<p>一大早群里就很热闹，看来暖暖的太阳比被窝还有吸引力。早餐过后就是小镇的走马观花，顺带还在院里pk了一下篮球。<br>以下是miss owl同学所拍摄的照片，超赞！<br><img src="http://meijing0114.qiniudn.com/meijing01146.pic.jpg?imageView2/2/q/85" alt="村景1"><br><img src="http://meijing0114.qiniudn.com/meijing01147.pic.jpg?imageView2/2/q/85" alt="村景2"><br><img src="http://meijing0114.qiniudn.com/meijing01148.pic.jpg?imageView2/2/q/85" alt="村景3"></p>
<p>大家明显都还带有晚睡的疲惫，中午一顿大餐过后，就要正式踏上归程了。回去的路上，云层丰富多彩，天空大开大合，城市与之相比不可同日而语。真想去美国50号公路自驾一下，体验一下人、车、路的那种融合！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/11/19/frontpage/" itemprop="url">
                  meijing0114的博客
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-11-19T22:29:47+08:00" content="Nov 19 2014">
              Nov 19 2014
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/生活随感/" itemprop="url" rel="index">
                    <span itemprop="name">生活随感</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/11/19/frontpage/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/11/19/frontpage/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>欢迎来到meijing0114的技术博客，这里会有个人技术成长过程中的各类漫谈。包括但不限于<strong>web后台技术</strong>、<strong>ios技术</strong>，以及<strong>服务器运维</strong>相关技术。</p>
<blockquote>
<p>穿越长城，走向世界</p>
<p>Accross the Great Wall we can reach every corner in the world.</p>
<p>Ueber die Grosse Mauer koennen wir alle Erke des Welt ereichen.</p>
</blockquote>
<h2 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h2><hr>
<p><em>php</em> <code>echo &quot;hello world!&quot;;</code></p>
<p><em>c++</em> <code>std::cout&lt;&lt;&quot;hello world!&quot;;</code></p>
<p><em>c</em> <code>printf(&quot;hello world!&quot;);</code></p>
<p><em>python</em> <code>print &quot;hello world!&quot;</code></p>
<hr>
<h2 id="web技术"><a href="#web技术" class="headerlink" title="web技术"></a>web技术</h2><ul>
<li><strong>数据层</strong>：<ul>
<li>mysql：高性能mysql</li>
<li>redis：</li>
<li>no-sql</li>
</ul>
</li>
<li><strong>逻辑层</strong>：<ul>
<li>MVC模型</li>
</ul>
</li>
<li><strong>接入层</strong>：<ul>
<li>nginx: 深入理解nginx</li>
<li>apache：</li>
<li>cache： memcache</li>
</ul>
</li>
<li><strong>web前端</strong><ul>
<li>js、jquery</li>
<li>css</li>
<li>html</li>
</ul>
</li>
<li><strong>运维相关</strong><ul>
<li>bash</li>
<li>shell</li>
</ul>
</li>
</ul>
<hr>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.jpg"
               alt="meijing0114" />
          <p class="site-author-name" itemprop="name">meijing0114</p>
          <p class="site-description motion-element" itemprop="description">记录科技与生活</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">55</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">meijing0114</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"meijing0114"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>
